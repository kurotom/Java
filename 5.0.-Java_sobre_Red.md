# Comunicaciones Java

La comunicación entre máquinas ocurren a bajo-nivel y en Java se manejan con librerías incorporadas. Uno de los beneficios de Java es enviar y recibir información sobre la red como si fuera I/O con algunas pequeñas diferencias en la conexiones al final de la cadena I/O.

*Channels* o canales son el medio por el cual ocurre la comunicación entre cliente-servidor, pudiendo ejecutar varias canales en distintos hilos o *threads*.

El paradigma Unix de un sistema Input/Output normalmente se designa como *Open-Read-Write-Close*.

Se debe hacer una llamada *Open*, obtener los permisos de uso del recurso a usar.
Una o varias llamadas *Read* y *Write*, para leer y guardar datos. Leer toma los datos desde objeto y escritura transfiere los datos al objeto.
Una vez terminado esto se llama *Close* para informar al S.O. que ha finalizado la utilización del recurso abierto.

Cuando *Comunicación entre procesos (IPC) y manejo de redes* es incorporado a UNIX se implementó la interace con IPC similar a la que utilizan los fichero *input/output*.

Un proceso para leer y escribir en UNIX tiene que usar *descriptores* que estén referidos al fichero, dispositivo o canales de comunicaciones (sockets).

El ciclo de vida de un descriptor aplicado a un canal de comunicación (socket) está determinado por 3 fases:

1. Creación : apertura del socket.
2. Lectura y Escritura : recepción y envío de datos por el socket.
3. Destrucción : cierre del socket.


Interface IPC en UNIX-BSD está implementada sobre protocolos de red *TCP* y *UDP*, los destinatarios de los mensajes se especifican como direcciones de socket, cada dirección y puerto es única.

Cuando los mensajes son enviados, estos se encolan en el socket hasta que sean transmitidos, cuando llegan a destino, estos mensajes son encolan en el socket de recepción hasta que el proceso que tiene que recibirlo haga las llamadas necesarias para recoger esos datos.

---

El código de cliente y servidor deben implementar hilos para recibir y enviar datos y no bloquearse esperando por una respuesta.

---

<br>

# Clases útiles en comunicaciones

## Socket - java.net.Socket

[https://docs.oracle.com/javase/8/docs/api/java/net/Socket.html](https://docs.oracle.com/javase/8/docs/api/java/net/Socket.html)

Implementa sockets en clientes, es dispositivo input/output *bloqueante*.

Es el objeto básico en toda comunicación a través de Internet, bajo el protocolo TCP. Esta clase proporciona métodos para la entrada/salida a través de streams que hacen la lectura y escritura a través de sockets muy sencilla.

Dentro de un `try/catch`.

* Server

```java
int puerto = 9999;

ServerSocket skServidor = new ServerSocket(puerto);

while (true) {
    Socket socketCliente = skServidor.accept();
    
    socketCliente.close();
}
```

* Cliente

```java
Socket socketCliente = new Socket(serverIP, puerto);

socketCliente.close()
```

| Metodo | Descripción |
|-|-|
| `.bind(SocketAddress direccion)` | enlaza el socket a una dirección. |
| `.connect(SocketAddress direccion, int timeout)` | conecta al servidor con timeout (opcional) específico. |
| `.close()` | cierra el socket |
| `.isBound()` | retorna boleano si está enlazado. |
| `.isClosed()` | retorna boleano si está cerrado. |
| `.isConnected()` | retorna boleano si está conectado. |
| `.getInputStream()` | retorna stream input del socket, usado por `DataInputStream`. |
| `.getOutputStream()` | retorna stream output del socket, usado por `DataOutputStream`. |

<br>

## InetSocketAddress - java.net.InetSocketAddress

> [InetSocketAddress - doc](https://docs.oracle.com/javase/8/docs/api/java/net/InetSocketAddress.html)

Implementa una dirección IP Socket (IP + puerto) o un par (hostname + puerto), el cual intenta ser creado para resolver un hostname. Si la resolución falla entonces la dirección es *unresolved*, pero puede todavía ser usado en algunas circunstancias como conectarse por medio de un proxy.

Provee de objeto inmutable usado para un socket para enlazar, conectar y retornar valores.

```java
InetSocketAddress direccion = new InetSocketAddress("0.0.0.0", 25554);
```

| Constructor | Descripción |
|-|-|
| `InetSocketAddress(InetAddress addr, int port)` | crea un socket desde una IP y puerto. |
| `InetSocketAddress(int port)` | crea un dirección socket a partir de un puerto. |
| `InetSocketAddress(String hostname, int port)` | crea una dirección socket desde un hostname y puerto. |

| Metodo | Descripción |
|-|-|
| `.createUnresolved(String host, int puerto)` | crea un socket sin resolver desde un hostname y puerto. |
| `.getAddress()` | obtiene la dirección. |
| `.getHostname()` | obtiene el hostname. |
| `.getPort()` | obtiene el numero puerto. |
| `.isUnresolved()` | comprueba si dirección es resuelta o no. |


<br>

## ServerSocket - java.net.ServerSocket

[https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html](https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html)

Es un objeto utilizado en las aplicaciones servidor para escuchar las peticiones que realicen los clientes conectados a ese servidor. Este objeto no realiza el servicio, sino que crea un objeto Socket en función del cliente para realizar toda la comunicación a través de él. 

Dentro de un `try/catch`.

Es un **objeto bloqueante**, es decir, permite solamente una conexión cliente-servidor.

* Server

```java
int puerto = 25554;

ServerSocket socketServer = new ServerSocket(puerto);

socketServer.accept();

socketServer.close();
```


| Método | Descripción |
|-|-|
| `.accept()` | escucha conexiones en el socket. |
| `.bind(SocketAddress direccion)` | enlaza *ServerSocket* a una dirección. |
| `.close()` | cierra socket. |
| `.close()` | cierra el socket |
| `.isBound()` | retorna boleano si está enlazado. |

<br>

# SocketChannel - java.nio.channels.SocketChannel

> [SocketChannel - doc](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SocketChannel.html)

Forma no bloquante para leer data desde *sockets*, permitiendo múltiples conexiones clientes estando en un hilo y no sobrecargar la red.

Cliente y servidor.

Dentro de bloque `try/catch`.

* Servidor

```java
SocketChannel server  = SocketChannel.open();
server.bind(new InetSocketAddress("0.0.0.0", 25554));

clientes = server.accept()

SocketChannel server = SocketChannel.open();
SocketAddress socketAddr = new InetSocketAddress("localhost", 9000);
server.connect(socketAddr)
```

* Cliente

```java
ServerSocketChannel serverSocket = null;
SocketChannel client = null;

serverSocket = ServerSocketChannel.open();
serverSocket.socket().bind(new InetSocketAddress(9000));

client = serverSocket.accept();
```

| Método | Descripción |
|-|-|
| `.bind(SocketAddress direccion)` | enlaza socket a una dirección. |
| `.connect(SocketAddress remota)` | conecta el canal socket. |
| `.getLocalAddress()` | retorna la dirección socket. |
| `.isConnected()` | retorna booleano si está conectado el socket. |
| `.open(SocketAddress remota)` | abre canal socket y lo conecta. |


<br>

# ServerSocketChannel - java.nio.channels.ServerSocketChannel

> [ServerSocketChannel - doc](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ServerSocketChannel.html)

Permite crear canales que escuchen conexiones en puerto TCP.

* Server - no bloqueante

```java
int puerto = 9999;

ServerSocketChannel serverSocketChnl = ServerSocketChannel.open();

serverSocketChnl.socket().bind(new InetSocketAddress(puerto));

serverSocketChnl.configureBlocking(false);

while (true) {
    SocketChannel socketChannel = serverSocketChnl.accept();
    
    if (socketChannel != null) {
            //  codigo
    }
    
    socketChannel.close();
}
serverSocketChnl.close();

```

| Método | Descripción |
|-|-|
| `.bind(SocketAddress direccionIp)` | enlaza dirección al socket. |
| `.accept()` | Acepta una conexión hechas con el canal socket. |
| `.open()` | abre el canal server-socket. |
| `.socket()` | retorna un server socket asociado con el canal. |
| `.getLocalAddress()` | retorna dirección enlazada al socket. |
| `.configureBlocking(boolean block)` | habilita o deshabilita modo bloqueante. |

<br>

## Channels - java.nio.channels.Channel

> [Channel - doc](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/Channel.html)

Interface que funciona como nexo (elemento que une) operaciones I/O.

Un canal representa una conexión abierta para una entidad como un dispositivo de hardware, fichero, socker de red, o un componente de programa para realizar operaciones I/O.

*Channels* soporta I/O no bloqueante, leer y escribir vía *ByteBuffers*, y I/O asincrónico.

Debe ser abierto o cerrado.

Podemos establecer conexiones mediante canales de conexión, para ello podemos utilizar `java.nio.channels.SocketChannel`.

Para recibir mensajes usar **BufferedReader**.
Para enviar mensajes utilizar **BufferedWriter** o **PrintWriter**.



| Métodos | Descripción |
|-|-|
| `.close()` | cierra el canal. |
| `.isOpen()` | retorna booleano si está abierto. |


<br>

## DatagramSocket - java.net.DatagramSocket

> [DatagramSocket - doc](https://docs.oracle.com/javase/8/docs/api/java/net/DatagramSocket.html)

La clase de sockets datagrama puede ser utilizada para implementar datagramas no fiables (sockets UDP), no ordenados.

Aunque la comunicación por estos sockets es muy rápida porque no hay que perder tiempo estableciendo la conexión entre cliente y servidor.

### Constructor

| Constructor | Descripción |
|-|-|
| `DatagramSocket()` | enlaza socket a cualquier puerto disponible en la máquina local. |
| `DatagramSocket(int port)` | enlaza puerto a maquina local. |
| `DatagramSocket(int port, InetAddress dirección)` | crea un socket datagrama, enlazada a dirección dada. |

### Métodos

| Métodos | Descripción |
|-|-|
| `.bind(SocketAddress direccion)` | enlaza a dirección. |
| `.close()` | cierra el datagrama socket. |
| `.connect(InetAddress direccion, int port)` | conecta socket a dirección remota para el socket. |
| `.disconnect()` | desconecta el socket. |
| `.isBound()` | retorna boleano si está enlazado. |
| `.isClosed()` | retorna boleano si está cerrado. |
| `.isConnected()` | retorna boleano si está conectado. |
| `.receive(DatagramPacket p)` | recibe paquetes datagram del socket. |
| `.send(DatagramPacket p)` | envía paquetes datagram del socket. |
| `.getSoTimeout()` | retorna configuración *SO_TIMEOUT*. |
| `.setSoTimeout(int timeout)` | establece configuración *SO_TIMEOUT* en milisegundos. |


<br>

## DatagramPacket - java.net.DatagramPacket

> [DatagramPacket - doc](https://docs.oracle.com/javase/8/docs/api/java/net/DatagramPacket.html)

Clase que representa un paquete datagrama conteniendo información de paquete, longitud de paquete, direcciones Internet y números de puerto.

Protocolo UDP.

### Constructor

| Constructor | Descripción |
|-|-|
| `DatagramPacket(byte[] buf, int length)` | Construye un DatagramPacket para **recibir paquetes** de *length* de largo. |
| `DatagramPacket(byte[] buf, int length, InetAddress direccion, int port)` |  Construye un DatagramPacket para **enviar paquetes** de *length* de largo para el puerto especificado y dirección. |
| `DatagramPacket(byte[] buf, int length, SocketAddress address)` | Construye un DatagramPacket para **enviar paquetes** del largo especificado por el puerto del host.  |


### Métodos

| Métodos | Descripción |
|-|-|
| `.setData(byte[] buf)` | establece data buffer del paquete. |
| `.setLength(int length)` | establece largo del paquete. |
| `.setPort(int port)` | establece el número del puerto. |
| `.setSocketAddress(SocketAddress direccion)` | establece dirección (ip + puerto) del host remoto. |
| `.setAddress(InetAddress iaddr)` | establece dirección IP de la máquina a la que se enviará. |
| `.getAddress()` | retorna dirección IP. |
| `.getData()` | retorna data buffer (bytes). |
| `.getLength()` | retorna el tamaño de la data. |
| `.getPort()` | retorna el puerto. |


<br>

## Uso de DatagramPacket  y DatagramSocket

* Enviar DatagramPacket por DatagramSocket

```java
DatagramSocket ds = new DatagramSocket();  

String str = "Welcome java";  

InetAddress ip = InetAddress.getByName("127.0.0.1");  
     
DatagramPacket dp = new DatagramPacket(
                                                                str.getBytes(),
                                                                str.length(),
                                                                ip,
                                                                3000
                                                            );  

ds.send(dp);

ds.close();
```

* Recibir DatagramPacket por DatagramSocket

```java
DatagramSocket ds = new DatagramSocket(3000);  

byte[] buf = new byte[1024];  

DatagramPacket dp = new DatagramPacket(buf, 1024);  

ds.receive(dp);  

String str = new String(
                                        dp.getData(),
                                        0,
                                        dp.getLength()
                                    );  

System.out.println(str);  

ds.close();  
```

<br>


## MulticastSocket - java.net.MulticastSocket

> [MulticastSocket - doc](https://docs.oracle.com/javase/8/docs/api/java/net/MulticastSocket.html)

Clase utilizada para crear una versión multicast de las clase socket datagrama. Múltiples clientes/servidores pueden transmitir a un grupo multicast (un grupo de direcciones IP compartiendo el mismo número de puerto).

<br>

## SocketImpl - java.net.SocketImpl

> [SocketImpl - doc](https://docs.oracle.com/javase/8/docs/api/java/net/SocketImpl.html)

Es un Interface que nos permite crearnos nuestro propio modelo de comunicación. Tendremos que implementar sus métodos cuando la usemos. Si vamos a desarrollar una aplicación con requerimientos especiales de comunicaciones, como pueden se la implementación de un cortafuegos (TCP es un protocolo no seguro), o acceder a equipos especiales (como un lector de código de barras o un GPS diferencial), necesitaremos nuestra propia clase Socket. 

<br>

# Conectar, enviar y recibir

Existen 3 cosas que se deben hacer en un cliente:

1. Establecer **conexión** entre cliente y servidor.
2. **Recibir** mensajes desde el servidor.
3. **Enviar** mensajes al servidor.

<br>

## Connectar

Se necesita una dirección IP y un puerto TCP.

Una conexión es una relación entre dos máquinas que se puedan comunicar entre ellas, enviando *bits* entre ellos.

Utiliza `java.nio.channels.SocketChannel` para crear un objeto de conexión.

```java
InetSocketAddress serverAddress = new InetSocketAddress("192.167.1.2", 5000);
SocketChannel socketChannel = SocketChannel.open(serverAddress);
```


Recordar que puertos 0 hasta 1023 están reservados para el sistema.
Desde 1024 hasta 65535 podemos utilizar para las aplicaciones.

<br>

## Recibir

Comunicarse con una conexión remota, se pueden utilizar implementaciones stream I/O antiguas o usar las nuevas implementaciones, en ambos casos, el programa funcionará como corresponde.

Utilizando **BufferedReader**.

```java
InetSocketAddress serverAddress = new InetSocketAddress("192.167.1.2", 5000);
SocketChannel socketChannel = SocketChannel.open(serverAddress);

Reader reader = Channels.newReader(socketChannel, StandardCharsets.UTF_8);

BufferedReader bufferedReader = new BufferedReader(reader);
String mensaje = bufferedReader.readLine();
```

<br>

## Enviar

Podemos utilizar **BufferedWriter** o **PrintWriter** (elegir esto cuando se escribe un String cada vez).

```java
InetSocketAddress serverAddress = new InetSocketAddress("192.167.1.2", 5000);
SocketChannel socketChannel = SocketChannel.open(serverAddress);

Writer reader = Channels.newWriter(socketChannel, StandardCharsets.UTF_8);

PrintWriter printWriter = new PrintWriter(reader);

writer.println("enviar mensaje")  // agrega salto línea al final
writer.print("Otro mensaje")  // no agrega salto línea

```


Otra forma de realizar una conexión es utilizando **Sockets**.


<br>

\pagebreak

<br>


# Sockets

Los sockets son puntos finales de enlaces de comunicaciones entre procesos. 

Los procesos los tratan como descriptores de ficheros, de forma que pueden intercambiar datos con otros procesos, transmitiendo y recibiendo datos por medio de sockets.

El tipo de socket describe la forma en la que se transfiere información por medio de ese socket.


1. **Sockets Stream (TCP, Transport Control Protocol)**

Servicio orientado a conexión donde los datos se transfieren sin encuadrarlos en registros o bloques.

Las interrupciones de conexión se informarán.

Comunicaciones con stream es un protocolo orientado a conexión, debido a que primero se debe establecer una conexión entre un par de sockets, uno atiende (servidor) y otro solicita (cliente), una vez conectados se procede a transmitir los datos en ambas direcciones.


2. **Sockets Datagram (UDP, User Datagram Protocol)**

Servicios de transporte sin conexión. Son más eficientes que TCP, pero no garantizan fiabilidad de los datos.

Los datos se envían y reciben en paquetes, la entrega no está garantizada. Los paquetes pueden ser duplicados, perdidos o llegar en orden diferente al que se envió.

Comunicaciones que utilizan este protocolo, no necesitan de conexión, es decir, cada vez que se envíen datagramas es necesario enviar el descriptor del socket local y la dirección del socket que debe recibir el datagrama. Por cada comunicación nueva se debe enviar datos adicionales.


3. Sockets Raw

Son sockets que dan acceso directo a la capa de software de red subyacente o protocolos de más bajo nivel.

Se utiliza para depuración del código de los protocolos.

<br>

# Diferencias entre Sockets Stream y Datagrama

Decidir cuál utilizar dependerá de la necesidad de la aplicación.

| TCP (Transport Control Protocol) | UDP (User Datagram Protocol) |
|-|-|
| Orientado a conexión, necesita establecer conexión entre sockets primero. | Por cada envío de datos se debe enviar el descriptor del socket local. |
| Es más lento debido a que debe establecer conexión entre sockets. | Es más rápido porque no establece conexiones, simplemente envía los datos. |
| La integridad de los datos está garantizada, los datos se leen en orden. | Los datos pueden llegar corruptos, desordenados, o no llegar. |
| No tiene límites de tamaño. | Tiene límite de tamaño de 64 kilobytes. |
| Protocolo Ordenado. | Protocolo desordenado. |
| Útil para la mayoría de programas de red, es más sencillo y menos posibilidades de presentar problemas. | Es menos complejo, tiene menos sobrecarga sobre la conexión, útil para aplicaciones cliente/servidor en sistemas distribuidos montados en red local. |

<br>

# Uso de Sockets

Un servidor es un conjunto de sockets que proporcionan capacidades adicionales del sistema, los **servicios**.

Cada servicio está asociado a un puerto. Un puerto es una dirección numérica en el cual se procesa el servicio.

En sistemas UNIX, los servicios que proporciona ese sistema están en el fichero **/etc/services**.

Algunos ejemplos:

| Nombre servicio | Puerto | Alias del servicio |
|-|-|-|
| daytime | 13/udp | |
| ftp | 21/tcp | |
| telnet | 23/tcp | telnet |
| smtp | 25/tcp | mail |
| http | 80/tcp | | 

<br>

## Cliente - socket

```java
try (Socket chatSocket = new Socket("127.0.0.1", 5000);) {

	InputStreamReader in = new InputStreamReader(chatSocket.getInputStream());

	BufferedReader reader = new BufferedReader(in);
	String mensaje = reader.readLine();

	PrintWriter writer = new PrintWriter(chatSocket.getOutputStream());

	writer.println("Un mensaje");

	writer.print("Otro mensaje");
	
	writer.flush();
	
	writer.close();
	reader.close()
	in.close();

} catch (IOException e) {
	e.printStackTrace();
}
```

<br>

# Clase URL

> [URL - doc](https://docs.oracle.com/javase/8/docs/api/java/net/URL.html)


La clase URL contiene constructores y métodos para la manipulación de **URL (Universal Resource Locator)**, un objeto o servicio en Internet.

El protocolo TCP necesita dos tipos de información:

* la dirección IP
* el número de puerto


El servicio *DNS (Domain Name Service)* traduce las direcciones nombradas, "dns.google.com" por ejemplo, a una dirección numérica, 8.8.8.8.

Para obtener la dirección IP real local se puede usar los métodos *.getLocalHost()* y *.getAddress()*.

*.getLocalHost()* retorna un objeto <u>[InetAddress](https://docs.oracle.com/javase/8/docs/api/java/net/InetAddress.html)</u> y si usamos *.getAddress()* en ese objeto retornará un array numérico de la dirección IP.

```java
InetAddress direccion = InetAddress.getLocalHost();
byte direccionIp[] = direccion.getAddress();

direccionIp[0] = 150
direccionIp[1] = 150
direccionIp[2] = 112
direccionIp[3] = 145 
```


Una red puede puede mapear múltiples direcciones IP, es necesario para un Servidor Web para soportar grandes cantidades de tráfico.

Al conocer una dirección IP solamente hace falta el número de puerto, al omitir dicho puerto, se utilizará el fichero */etc/services* en sistemas UNIX-BSD, fichero *services* en Windows-NT.

Por defecto el servicio web tiene puerto 80, ftp tiene 21 por defecto. El protocolo *HTTP (HyperText Transmission Protocol)* se utiliza para manipular documentos web, de omitir el nombre del fichero a obtener, por defecto entrega *index.html*.

Cuatro constructores de clase *URL*.

```java
public URL( String spec ) throws MalformedURLException;

public URL( String protocol,String host,int port,String file ) throws MalformedURLException;

public URL( String protocol,String host,String file ) throws MalformedURLException;

public URL( URL context,String spec ) throws MalformedURLException;
```

Ejemplos de uso:

```java
URL( "http","www.yahoo.com","80","index.html" );


URL( "http://www.yahoo.com" );
```

<br>

# Dominio de comunicaciones

El mecanismo sockets está diseñado para comunicarse dentro de dominios de comunicación, no contiene información suficiente para describir la comunicación entre procesos.

Dentro del mismo dominio de comunicación, entre ellos se define si los dos procesos que se comunican se encuentran en el mismo sistema o en sistemas diferentes y cómo pueden ser direccionados.

<br>

## Dominio UNIX

Tiene dos dominios:

* Comunicaciones internas al sistema.

* Comunicaciones entre sistemas : ocurren en la misma máquina (intrasistema), entre dos procesos del mismo sistema en una máquina UNIX en el dominio UNIX. Se permiten tanto sockets stream como los datagramas. Los sockets de dominio Unix bajo SOlaris 2.X se implementan sobre *TLI (Transport Level Interface)*.
No se permiten sockets Raw.

<br>

## Dominio Internet

Comunicaciones intersistemas proporcionan acceso a TCP, ejecutando sobre **IP (Internet Protocol)*, de la misma forma que el dominio UNIX, el dominio Internet permite tanto sockets stream como datagrama, además permite sockets Raw.

*Sockets Stream* permiten la comunicación entre procesos por medio de TCP, establecidas las conexiones, los datos se pueden leer y escribir hacia/desde los sockets como un flujo (stream) de bytes.

Algunas aplicaciones de servicios TCP son:

* File Tranfer Protocol, *FTP*.
* Simple Mail Transfer Protocol, *SMTP*.
* *TELNET*, servicio de conexión de terminal remoto.


Los sockets datagrama permiten a los procesos utilizar el protocolo UDP para comunicarse hacia/desde los sockets por medio de bloques.

UDP es un protocolo no fiable y no está garantizada la entrega los paquetes.

Servicios UDP son:

* Simple Network Management Protocol, *SNMP*.
* Trivial File Transfer Protocol, *TFTP* (versión de FTP sin conexión).
* Versatile Message Transaction Protocol, *VMTP* (servicio fiable de entrega punto a punto de datagramas independiente de TCP).


Los sockets Raw proporcionan acceso al *ICMP - Internet Control Message Protocol* y se utiliza para comunicarse entre entidades IP.

<br>

# Modelo de comunicaciones con Java

Para crear conexión socket TCP/IP en Java se utiliza el paquete **java.net**, **java.nio**, **java.nio2**.

Diagrama cliente/servidor.

```
       Servidor                                                       Cliente

ServerSocket(port, timeout)                       Socket(host, port)
  
--------------                                                       --------------
 OutputStream   <-------  Thread  -------->   InputStream
 InputStream    <--------  Thread  -------->   OutputStream
 --------------                                                     --------------
     close()                                                         close()
```


El servidor establece un puerto y espera un tiempo en segundos (timeout) para que el cliente establezca la conexión.

El cliente establece la conexión al *host* por medio del puerto.

El cliente y el servidor se comunican con manejadores *InputStream* y *OutputStream*.

* **Utilizar try con recursos - java 7+** .

<br>

# Apertura de Sockets

Cliente/Servidor se comunican usando **Channels**

Un canal representa una conexión entre *dos aplicaciones*.

Un cliente debe tener una ip y puerto TCP, puerto TCP es un número de 16-bits que no esté siendo usado por otra aplicación.

Es necesario utilizar un manejador de excepciones (try-catch).

Utilizar puertos 1024 y menores están reservados para usuarios con muchos privilegios, estos puertos son los que utilizan servicios estándares como ftp, smtp, http. Aplicaciones comunes utilizan puertos mayores a 1024.

**ServerSocketChannel** espera por peticiones de clientes utilizando un puerto.

**SocketChannel** se crea cuando **ServerSocketChannel** acepta el cliente mediante *.accept()*.


<br>


# Streams Entrada

Podemos utilizar **InputStream** para obtener el flujo de entrada hacia el cliente o en el servidor.

Otra opciones es **DataInputStream**, **InputStreamReader** para crear un stream de entrada listo para recibir las respuestas del servidor.

Para leer información texto desde el servidor, se debe crear un **BufferedReader**, asignado a **Reader**, **Reader** es un middleware (puente) que toma los bytes y los convierte en texto.

*DataInputStream* permite lectura de texto y tipos primitivos de Java (esto lo hace altamente portable), tiene métodos para leer:

* *.read()*
* *.readChar()*
* *.readInt()*
* *.readDouble()*
* *.readLine()*

Dependiendo del tipo de datos, el uso de cada método.

Podemos recibir/leer información utilizando *Channels* de la siguiente forma:

```java
Reader channelReader = Channels.newReader(canalSocket, StandardCharsets.UTF_8);

BufferedReader reader = new BufferedReader(channelReader);
```

<br>


# Streams Salida

Podemos utilizar **OutputStream** para enviar información hacia el cliente o en el servidor.

En el cliente, debemos crear un stream para enviar datos al socket del servidor utilizando las clases **PrintStream**, **DataOutputStream** o **PrintWriter**:

Para escribir texto hacia el servidor, creamos **PrintWriter** encadenado a **Writer**, utilizar *.print()* o *.println()* para enviar el mensaje String.

*PrintStream*, tiene métodos para la representación textual de todos los datos primitivos Java. Métodos *write()* y *println()* son muy importantes.

*DataOutputStream*, permite escribir cualquiera de los tipos primitivos Java, varios de sus métodos escriben cualquier tipo primitivo en el stream de salida, el más útil es *.writeBytes()*.

Podemos enviar/escribir información utilizando *Channels*:

```java
Writer writerChannel = Channels.newWriter(canalSocket, StandardCharsets.UTF_8);

PrintWriter writer = new PrintWriter(writerChannel);

writer.println("un mensaje");

writer.flush();
```

<br>


# Cierre de sockets

Siempre se deben cerrar los sockets abiertos de entrada y salida en el cliente y servidor.

En cada objeto de conexión tenemos el método **`.close()`** para cerrar la conexion.

Es recomendable utilizar **try with resources - java 7+** para crear conexiones.


<br>

# PrintWriter - java.io.PrintWriter

> [PrintWriter - doc](https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html)

Imprime representaciones formateados de objetos a un stream de salida de texto. Esta clase implementa todas los métodos *print* de `PrintStream`.

No contiene métodos para escribir bytes raw, por lo cual, el programa debe usar bytes sin codificar.

Envía automáticamente los datos al usar `println`, `printf` o `format`.

| Constructor | Descripción |
|-|-|
| `PrintWriter(File file)` | crea un nuevo *PrintWrite*, con un fichero específico. |
| `PrintWriter(File file, String csn)` | crea un nuevo *PrintWrite*, con un fichero y charset específico. |
| `PrintWriter(OutputStream out)` | crea un nuevo *PrintWrite*, de un `OutputStream`. |
| `PrintWriter(OutputStream out, boolean autoFlush)` | crea un nuevo *PrintWrite*, desde un `OutputStream` existente. |
| `PrintWriter(String fileName)` | crea un nuevo *PrintWrite*, con un nombre de fichero. |
| `PrintWriter(String fileName, String csn)` | crea un nuevo *PrintWrite*, con un nombre de fichero y charset específico. |
| `PrintWriter(Writer out)` | crea un nuevo *PrintWrite*. |
| `PrintWriter(Writer out, boolean autoFlush)` | crea un nuevo *PrintWrite*. |

| Métodos | Descripción |
|-|-|
| `.append(char c)` | agrega carácter al writer. |
| `.append(CharSequence csq)` | agrega secuencia de carácteres especificados a un writer. |
| `.append(CharSequence csq, int start, int end)` | agrega secuencia de carácteres dentro de un rango a un writer. |
| `.println(elemento item)` | imprime un elemento y agrega una línea nueva al final. |
| `.print(elemento item)` | imprime un elemento y sin una línea nueva al final. |
| `.write(String s)` | escribe un string. |
| `.write(String s, int off, int len)` | escribe una porción de string. |
| `.flush()` | envía el stream. |

<br>

# PrintStream - java.io.PrintStream

> [PrintStream - doc](https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html)

Agrega funcionalidad a otra salida, nunca *throws* una *IOException*, en lugar, situaciones excepcionales son marcadas internamente mediante método `checkError`.


| Constructor | Descripción |
|-|-|
| `PrintStream(File file)`  | crea un nuevo print stream, con un fichero específico. |
| `PrintStream(File file, String csn)` | crea un nuevo print stream, de un fichero y carácter específico. |
| `PrintStream(OutputStream out)` | crea un nuevo print stream. |
| `PrintStream(OutputStream out, boolean autoFlush)` | crea un nuevo print stream. |
| `PrintStream(OutputStream out, boolean autoFlush, String encoding)` | crea un nuevo print stream. |
| `PrintStream(String fileName)` | crea un nuevo print stream, con nombre del fichero. |
| `PrintStream(String fileName, String csn)` | crea un nuevo print stream, con el nombre del fichero y charset. | 


| Métodos | Descripción |
|-|-|
| `.append(char c)` | agrega carácter al writer. |
| `.append(CharSequence csq)` | agrega secuencia de carácteres especificados a un writer. |
| `.append(CharSequence csq, int start, int end)` | agrega secuencia de carácteres dentro de un rango a un writer. |
| `.println(elemento item)` | imprime un elemento y agrega una línea nueva al final. |
| `.print(elemento item)` | imprime un elemento y sin una línea nueva al final. |
| `.write(String s)` | escribe un string. |
| `.write(String s, int off, int len)` | escribe una porción de string. |
| `.flush()` | envía el stream. |


<br>

# InputStream - java.io.InputStream

> [InputStream - doc](https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html)

Clase abstracta, es la superclase de todas las clases que representan stream input de bytes.

| Métodos | Descripción |
|-|-|
| `.available()` | retorna número estimado de bytes para que puedan ser leídos. |
| `.close()` | cierra el stream de entrada. |
| `.mark(int marca)` | marca la posición actual en el stream. |
| `.markSupported()` | comprueba si stream de entrada soporta marcado. |
| `.read()` | lee el siguiente byte del stream input. |
| `.read(byte[] b)` | lee algunos bytes del stream input y los almacena en un array byte. |
| `.read(byte[] b, int off, int len)` | lee hasta el tamaño bytes de data desde el stream input a un array de bytes. |
| `.reset()` | reinicia las marcas del stream, si las tiene. |
| `.skip(long n)` | salta y descarta bytes de data desde input stream. |


<br>

# OutputStream - java.io.OutputStream

> [OutputStream - doc](https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html)

Clase abstracta, es la superclase de todas las clases que representan stream output de bytes.

| Método | Descripción |
|-|-|
| `.close()` | cierra stream. |
| `.flush()` | envía stream. |
| `.write(byte[] b)` | escribe *b.length* bytes del array byte al stream output. |
| `.write(byte[] b, int off, int len)` | escribe *len* bytes del array byte comenzando con *off* hacia el stream. |
| `.write(int b)` | escribe byte específico del output stream. |


<br>

# DataInputStream - java.io.DataInputStream

> [DataInputStream - doc](https://docs.oracle.com/javase/8/docs/api/java/io/DataInputStream.html)

Un flujo de entrada de datos permite que una aplicación lea tipos de datos Java primitivos de un flujo de entrada subyacente de forma independiente de la máquina. Una aplicación utiliza un flujo de salida de datos para escribir datos que luego pueden ser leídos por un flujo de entrada de datos.

`DataInputStream` no es necesariamente seguro para el acceso multiproceso. La seguridad de subprocesos es opcional y es responsabilidad de los usuarios de los métodos de esta clase.

| Constructor | Descripción |
|-|-|
| `DataInputStream(InputStream in)` | crea un `DataInputStream` que usa el sistema adyacente `InputStream`. |

| Método | Descripción |
|-|-|
| `.close()` | cierra el stream. |
| `.read(byte[] b)` | lee algunos bytes de data. |
| `.read(byte[] buf, int off, int len)` | lee un array de bytes. |
| `.readBoolean()` | lee boleanos. |
| `.readByte()` | lee 8 bit byte. |
| `.readChar()` | lee 16 bit char. |
| `.readDouble()` | lee 64 bit double. |
| `.readFloat()` | lee 32 bit float. |
| `.readInt()` | lee 32 bit int. |
| `.readLong()` | lee 64 bit long. |
| `.readShort()` | lee 16 bit short. |
| `.readObject()` | lee un objeto. Para leer String se debe hacer *cast*. |


<br>

# DataOutputStream - java.io.DataOutputStream

> [DataOutputStream - doc](https://docs.oracle.com/javase/8/docs/api/java/io/DataOutputStream.html)

Un flujo de salida de datos permite que una aplicación escriba tipos de datos Java primitivos en un flujo de salida de forma portátil. Luego, una aplicación puede usar un flujo de entrada de datos para volver a leer los datos.

| Constructor | Descripción |
|-|-|
| `DataOutputStream(OutputStream out)` | crea un nuevo stream output para escribir data. |


| Método | Descripción |
|-|-|
| `.close()` | cierra el stream. |
| `.reset()` | reinicia el estado de cualquier objeto en el stream. |
| `.writeObject(Objet objeto)` | escribe un elemento Object (cualquier cosa), usar esto para escribir String. |
| `.writeInt(int val)` | escribe int. |
| `.writeFloat(float val)` | escribe float. |
| `.writeDouble(double val)` | escribe double. |
| `.writeChar(int val)` | escribe 16 bit char. |
| `.writeChars(String str)` | escribe secuencia chars. |
| `.writeFields()` | escribe los fields. |
| `.writeLong(long val)` | escribe long. |
| `.writeShort(int val)` | escribe short. |
| `.writeUTF(String str)` | escribe data primitiva de String modificado UTF-8. |
| `.flush()` | envia el stream. |


<br>

# InputStreamReader - java.io.InputStreamReader

> [InputStreamReader - doc](https://docs.oracle.com/javase/8/docs/api/java/io/InputStreamReader.html)

Un `InputStreamReader` es un puente entre flujos de bytes y flujos de caracteres: lee bytes y los decodifica en caracteres utilizando un juego de caracteres específico. El juego de caracteres que utiliza se puede especificar por nombre o se puede dar explícitamente, o se puede aceptar el juego de caracteres predeterminado de la plataforma.

Cada invocación de uno de los métodos `.read()` de `InputStreamReader` puede hacer que se lean uno o más bytes del flujo de entrada de bytes subyacente. Para habilitar la conversión eficiente de bytes a caracteres, se pueden leer más bytes del flujo subyacente de los necesarios para satisfacer la operación de lectura actual.

```java
BufferedReader in = new BufferedReader(
                                                            new InputStreamReader(System.in)
                                                        );
```


| Constructor | Descripción |
|-|-|
| `InputStreamReader(InputStream in)` | crea un `InputStreamReader` que usa charset por defecto. |
| `InputStreamReader(InputStream in, Charset cs)` | crea un `InputStreamReader` que usa un charset dado. |
| `InputStreamReader(InputStream in, CharsetDecoder dec)` | crea un `InputStreamReader` que usa un decoder charset dado. |
| `InputStreamReader(InputStream in, String charsetName)` | crea un `InputStreamReader` que usa un charset usando un string. |

| Métodos | Descripción |
|-|-|
| `.close()` | cierra stream. |
| `.getEncoding()` | retorna el nombre del codificación de carácteres. |
| `.read()` | lee un único carácter. |
| `read(char[] cbuf, int offset, int length)` | lee carácteres en una porción de un array. |
| `ready()` | indica si stream está listo para leer. |


<br>


# OutputStreamWriter - java.io.OutputStreamWriter

> [OutputStreamWriter - doc](https://docs.oracle.com/javase/8/docs/api/java/io/OutputStreamWriter.html)

Un `OutputStreamWriter` es un puente entre los flujos de caracteres y los flujos de bytes: los caracteres escritos en él se codifican en bytes utilizando un juego de caracteres específico. El juego de caracteres que utiliza se puede especificar por nombre o se puede dar explícitamente, o se puede aceptar el juego de caracteres predeterminado de la plataforma.

Cada invocación de un método `write()` hace que el convertidor de codificación se invoque en los caracteres dados. Los bytes resultantes se acumulan en un búfer antes de escribirse en el flujo de salida subyacente. Se puede especificar el tamaño de este búfer, pero por defecto es lo suficientemente grande para la mayoría de los propósitos. Tenga en cuenta que los caracteres que se pasan a los métodos `write()` no se almacenan en el búfer.

```java
Writer out = new BufferedWriter(
                                                    new OutputStreamWriter(System.out)
                                                );
```


| Constructor | Descripción |
|-|-|
| `OutputStreamWriter(OutputStream out)` | crea un `OutputStreamWriter` que usa el caracter por defecto. |
| `OutputStreamWriter(OutputStream out, Charset cs)` | crea un `OutputStreamWriter` que usa el charset dado. |
| `OutputStreamWriter(OutputStream out, CharsetEncoder enc)` | crea un `OutputStreamWriter` que usa el encoder charset dado. |
| `OutputStreamWriter(OutputStream out, String charsetName)` | crea un `OutputStreamWriter` que usa un string del nombre de un charset. |


| Métodos | Descripción |
|-|-|
| `.close()` | cierra stream. |
| `.flush()` | envía el stream. |
| `.getEncoding()` | obtiene codificación usado en el stream. |
| `.write(char[] cbuf, int off, int len)` | escribe una porción de un array de carácteres. |
| `.write(int c)` | escribe un único carácter. |
| `.write(String str, int off, int len)` | escribe una porción del String. |


<br>

\pagebreak

<br>


# Escribiendo una aplicación cliente-servidor


## Cliente

Debe crear una conexión, crear los streams para recibir y enviar los datos, cerrar la conexión.

```java
InetSocketAddress serverAddress = new InetSocketAddress("127.0.0.1", 5000);

try (SocketChannel socketChannel = SocketChannel.open(serverAddress)) {

	Reader channelReader = Channels.newReader(socketChannel, StandardCharsets.UTF_8);
	
	BufferedReader reader = new BufferedReader(channelReader);
	
	String aviso = reader.readLine();
	
	System.out.println("Es un mensaje de aviso: " + aviso);
	
	reader.close();
	
} catch (IOException e) {
	e.printStackTrace();
}
```

<br>

## Servidor

El servidor crea un *ServerSocketChannel* y lo asocia a un puerto específico.

Luego el cliente se conecta mediante *SocketChannel* al servidor.

Entonces, el servidor crea un nuevo *SocketChannel* para comunicarse con el cliente, y acepta la conexion mediante *.accept()*.

*ServerSocketChannel* retorna a esperar otros clientes, teniendo solamente un par *ServerSocketChannel*/*SocketChannel*.

Pero tiene una limitante, este servidor solamente permite la conexión de 1 cliente a la vez.

```java
try (
        ServerSocketChannel serverChannel = ServerSocketChannel.open()
    ) {

	serverChannel.bind(new InetSocketAddress(5000));  // puerto escucha

 // bucle si el canal está abierto
	while (serverChannel.isOpen()) {
		SocketChannel clienteChannel = serverChannel.accept();  // acepta cliente
		
		PrintWriter writer = new PrintWriter(Channels.newOutputStream(clienteChannel));
		
		String aviso = "Un aviso desde el servidor";
		
		writer.println(aviso);  // envía el mensaje
		writer.flush();
		
		writer.close();  // cierra la escritura de mensaje
		
	} catch (IOException e) {
		e.printStackTrace();
	}
	

}
```

El código anterior, las conexiones son bloqueantes, es decir, que el cliente se conecta al servidor, este último, espera a que el cliente le envíe la información y se bloquea todo ese tiempo, limitando la capacidad de conexión a 1 cliente por instancia del servidor creada, esto es ineficiente.

Para solventar esto en el servidor, se debe implementar *Threads* para crear hilos y que cada hilo corresponda a cada conexión de cliente/servidor teniendo su propio espacio separado.

<br>

\pagebreak

<br>


# Threads - trabajos en hilos

Para poder enviar y recibir simultáneamente requerimos que se realicen estas tareas en áreas separadas.

Por cada hilo, en Java, tiene su propio *call stack*.

Java tiene soporte para múltiples hilos.

```java
Thread t = new Thread();
t.start();
```


El código anterior crea un objeto `Thread` que se lanzará por separado al *hilo de ejecución actual* dentro de su propio *Stack*.

Esta implementación nace y muere al instante, porque no tiene código que ejecutar. La razón de `Thread` es la realización de trabajos en un hilo independiente.

Múltiples hilos en Java quiere decir que tenemos tanto *thread* y *job* que están corriendo por el hilo.

Existen más formas de realizar múltiples trabajos en Java, no solamente utilizando clase *Thread* (java.lang.Thread).


* Representación de un hilo o *thread*.

```
x.baz()             doMore()
y.bar()             go()
x.foo()             doStuff() 
main()              run()
main thread         thread 2 - main
```

*thread*, es un hilo de ejecución separado del espacio de ejecución, es decir, separado del *Call Stack*. Cada aplicación Java inicia un main thread - el que pone el método *main()* al final del stack.

JVM es responsable de iniciar el hilo principal y otros hilos, incluyendo hilo garbage collection.


* Representación clase Thread - java.lang.Thread

```
Thread

void join()
void start()

static void sleep()
```

`Thread` es una clase que representa un hilo de ejecución. Este tiene métodos para iniciar, incorporar, dormir y otros métodos que trabajan con hilos.


## 3 estados del hilo

Cuando se crea un *Thread* y se le pasa un *Runnable* o se esté usando *Executor* para ejecutar un *Runnable*, en ambos casos todavía se ejecutará en un *Thread*.

Un *Thread* se moverá a través de un número diferente de estados durante su vida, entendiendo estos estados y transiciones entre estos, nos ayudará a entender mejor la programación multihilo.

Estados de un **Thread**:

1. New  : Una instancia *Thread* se tiene que crear pero no iniciar.


2. Runnable  : Cuando se inicia el hilo este se mueve a un estado ejecutable, es decir, que el hilo está listo para ser ejecutado y está esperando que sea seleccionado para ejecución. En este punto, existe un nuevo *call stack* para el hilo.


3. Running  : Este es el estado que todos los hilos quieren, estar en la cima del *thread stack* y ser ejecutados.

<br>

Solamente el manejador de hilos de JVM puede tomar esa decisión, podemos simplemente influenciar dicha decisión, pero no forzarla.

En este estado, solamente un hilo puede activar el *call stack* y el método al comienzo del stack es ejecutado.

Podemos enviarlos atrás, moverlos entre estado ejecutable, ejecutándo, o adicionalmente en un estado temporal de *no ejecutable*.

<br>

## Loop runnable/running

Típicamente el hilo se mueve entre estados runnable y running, es la JVM quien selecciona un hilo para ejecutar y envía otro a la espera.

Un hilo puede tener el estado *temporalmente no ejecutable*. El manejador de hilos puede enviar un hilo atrás y bloquear su estado, por ejemplo, el hilo ejecuta un código para leer desde una entrada de flujo, pero todavía no existe ningún dato para leer.

El manejado moverá el hilo fuera del estado running hasta que esté disponible. O ejecutará el código hasta que el hilo sea puesto a dormir (*sleep()*). O esperar que sea bloqueado. En cualquiera de los casos el hilo no puede continuar y esté *temporalmente en estado no ejecutable*.

<br>

## Manejador de hilos

Es el que toma la decisiones sobre quien mueve a estado *runnable* a *running*, y sobre cuando y en qué circunstancias un hilo deja de estar en estado corriendo.

Decide quién, por cuánto tiempo y qué hilos sacará del actual estado de ejecución.

Es un comportamiento autónomo de JVM. La implementación de comportamiento son diferentes en las distintas JVM incluso con los mismo programas en la misma máquina pueden dar resultados diferentes.

Uno de los errores comunes es probar programas multihilo en una única máquina y asumir que funciona como debe.

El código Java se puede ejecutar en donde sea, por la plataforma que la respalda, programas multihilo funcionarán sin importar *cómo* el hilo se comporte.

Programas multihilos son *no deterministas*, no se ejecutan de la misma forma cada vez, el manejador de hilos se puede tratar los hilos de forma distinta cada vez.

Incluso si el nuevo hilo es chico, tenga una línea solamente (una expresión lambda), este puede ser interrumpido por el manejador de hilos.

<br>

## Expresiones lambda o clase Runnable

Depende de cuán complicado es el trabajo, también si te es fácil entender expresiones lambda o una clase.

<u>*Expresiones lambda* son buenas para un trabajo realmente chico</u>, como una línea de código "print". De igual manera métodos de referencias.

```java
executor.execute(() -> printMSG());
```

---

* **Al usar una instancia de una clase de escritura o lectura, se "borra" los datos anteriores porque se crea un nuevo objeto.**

* **Ejecución de trabajos aislados o nuevos en el caso de uso de clases de escritura, por ejemplo.**

* **Para crear hilos de escritura y lectura de sockets, NO se debe utilizar expresiones lambda al principio en el método que tiene el código de implementación del servidor o cliente..**

```java
public void runServer() {
    try {
        // código implementación servidor
        
        hilos.submit(() -> new ClaseRead(socket, printReaderObj));
        
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

El método anterior, *runServer()*, al iniciar el servidor no recibirá mensajes porque el pool de hilos no tiene una instancia de la clase del servidor que escuche o lea mensajes creados al iniciar el servidor.

```java
public void runServer() {
    try {
        // código implementación servidor
        
        hilos.submit(new ClaseRead(socket, printReaderObj));
        
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

Al *No usar expresiones lambda al inicio* instanciamos la clase de servidor que lee los mensajes y se mantiene activo en un hilo.

Ahora se puede crear una clase de escritura o se puede crear un método que haga la escritura, si se quiere una escritura continua se debe utilizar hilos.

* Mensajes de una instancia

```java
public void sendMessage(String mensaje) {
    try {
        outData.println(mensaje);
        outData.flush();
    } catch (Exception e) {
        e.prinStackTrace();
    }
}
```

* Mensajes continuos en un hilo

```java
// método "runServer"
hilos.submit(new ClaseWriter(socket, printWriterObj));
```

```java
// clase ClaseWrite
Scanner scan = new Scanner(System.in);
String mensaje = null;
while (true) {
    System.out.print(">:  ");
    String msg = scan.nextLine();
    outData.println(msg);
    outData.flush();
}
```
---

Clases *Runnable* se usan para realizar trabajos como almacenar cosas en campos o si el trabajo tiene un número de métodos considerables. Esta se utilizan para realizar trabajos más complejos.

<br>

## Más de 1 Call Stack

Teniendo más de un Call Stack muchas cosas pueden suceder al mismo tiempo. Si se está ejecutando en un sistema multiprocesador (computadores y teléfonos modernos), puedes realizar múltiples cosas al mismo tiempo. Incluso puedes realizarlas en sistemas sin multiprocesamiento.

La ejecución puede enviarse a segundo plano y recuperarse rápidamente cuando se requiera y todos los stacks se están ejecutando al mismo tiempo.

Java ejecuta cualquier stack que esté al principio o esté manejando actualmente, pudiendo cambiarse a otro stack.

Los hilos mantienen un seguimiento de cuales métodos se están ejecutando actualmente en el *thread stack*.

A grandes rasgos se tendría lo siguiente:

1. JVM llama al método *main()*

```java
public static void main(String[] args) {
	...
}
```


2. *main()* inicia un nuevo hilo. El hilo principal puede ser temporalmente congelado mientras el nuevo hilo comienza a ser ejecutado.

```java
Runnable r = new MyThreadJob();
Thread t = new Thread(r);
t.start();

Dog d = new Dog();
```


3. JVM cambia desde el nuevo hilo creado al hilo principal, esto lo realiza hasta que ambos se completen.

```
Dog()            x.go()
main()           run()
main thread      user thread "t"
```

<br>

# Runnable - java.lang.Runnable

> [Runnable - doc](https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html)

Interface `Runnable` es para un hilo como para job es para un worker. Un `Runnable` es el trabajo de un hilo que se suponer ejecutar (run).

Para iniciar un nuevo *call stack* el hilo necesita un job - un hilo de trabajo se ejcutará cuando se inicie.

El trabajo es actualmente el primer método que se manda al nuevo *thread stack*, y siempre debe ser un método como el siguiente:

```java
public void run() {
	// Código ACA, SIEMPRE se debe implementar este método al usar INTERFACE Runnable
}
```


Como *Runnable* es una interface, o una expresión lambda, que tiene el método *run()*.

Una vez que se tiene la clase Runnable, le dice a JVM para correr el código en un hilo separado, estás entregando un trabajo a su propio hilo.

Es en el método *run()* en donde se debe poner el *job* del hilo que se quiera ejecutar. Este método NO recibe argumentos.

<br>

## Creando una clase Runnable

```java
public class MyRunnable implements Runnable {

	public void run() {
		go();
	}
	
	public void go() {
		doMore();
	}
	
	public void doMore() {
		System.out.println(Thread.currentThread().getName() + ": top of the stack.");
		
		Thread.dumpStack();
	}
	
	public static void main(String[] args) {
		ClassThreadRunnable c = new ClassThreadRunnable();
		Thread mythread = new Thread(c);
		
		mythread.start();
		
		System.out.println(Thread.currentThread().getName() + ": back in main");
		
		Thread.dumpStack();
	}
}
```

Con esto ahora tendremos dos *call stack*, el principal y el nuevo hilo creado.

*.dumpStack()* llamado desde *.doMore()* desde clase *MyRunnable* y desde método *.main()* (puede ser desde cualquier clase). Este método es para fines de depuración.

Esta clase se ejecutará, pero generará un error (*.dumpStack()*) para mostrar cómo se ejecutará las instrucciones.

<br>

## Evitar hacer

* No se puede llamar al método *.run()* de **Runnable** dentro del método *.main()* de cualquier clase, porque este no es parte del *call stack* del hilo main.

* LLamar o instanciar y ejecutar *.run* desde *main()* no es suficiente para crear un nuevo *call stack*.

<br>

# Thread to Sleep

Para enviar a dormir un thread simplemente se utiliza el método estático **Thread.sleep(time_miliseconds)**.

Poner a dormir un hilo permite a otros hilos ejecutarse y cuando cambia el estado a *runnable*, es el manejador de hilos quien decide cuándo el hilo que volvió se ejecutará nuevamente.

Poner a dormir un hilo permite tener un comportamiento más predecible.

Debe ir entre try/catch para elevar *InterruptedException* que eleva *sleep*.

```java
try {
	Thread.sleep(2000);
} catch (InterruptedException ex) {
	ex.printStackTrace();
}
```


Ahora el hilo no despertará antes del tiempo indicado, una vez que el tiempo se cumple el manejador de hilo lo controlará nuevamente, lo cual no garantizará sobre cuánto el tiempo estará fuera de acción.

Una vez que el tiempo se cumple, el hilo vuelve al estado runnable y espera para el manejador de hilos para elegirlo y ejecutarlo nuevamente.

Se puede utilizar la clase **java.util.concurrent.TimeUnit** para hacer más legible el tiempo *sleep*, aún debe ir entre *try-catch*.

```java
try {
	TimeUnit.MINUTES.sleep(2);
} catch (InterruptedException ex) {
	ex.printStackTrace();
}
```

Lo cual es más fácil de entender que:

```java
try {
	Thread.sleep(120000);
} catch (InterruptedException ex) {
	ex.printStackTrace();
}
```

<br>

## Usar sleep para hacer el programa más predecible

El manejador de hilos es quien controla de forma autónoma los estados de los hilos, por lo que, no se garantiza una ejecución completamente uniforme en los distintos entornos de ejecución (incluso en las mismas máquinas).

Los hilos en estado *running* con el uso de *sleep* permite esperar hasta que este hilo finalice, enviando a los nuevos hilos al estado *runnable* antes que finalice.

<br>

## Uso de *sleep* en código

```java
class PredictableSleep {
	public static void main(String[] args) {
	
		ExecutorService executor = Executors.newSingleThreadExecutor();
		
		executor.execute(() -> sleepThenPrint());
		
		System.out.println("back in main");
		
		executor.shutdown();
	}
	
	private static void sleepThenPrint() {
		
		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("top of the stack");
		
	}
}
```

El código anterior:

* En la línea *executer.execute()* se utilizó un lambda que llama a un método estático privado en donde se utiliza *sleep*.
* *Thread.sleep* eleva una *checked Exeption*.
* *sleep* en medio de *try-catch* con tiempo utilizando *TimeUnit*.
* Cumplido el tiempo, imprime el mensaje.

<br>

## Desventajas de sleep

1. El programa espera la cantidad de tiempo indicada.

Poniendo a dormir por 2 segundos, el hilo es *no-ejecutable* ese tiempo. El manejador de hilos decidirá si se ejecuta el hilo.

2. ¿Cómo saber si otro trabajo terminará en dicho tiempo?

Una forma de lidiar con ello, es establecer un tiempo estimado en que el trabajo terminará, pero existe un problema, no siempre se puede estimar el tiempo correcto de cuando se termine el trabajo.

Una buena alternativa es *esperar el tiempo perfecto*.

Coordinar eventos entre múltiples hilos, un hilo puede esperar por una señal desde otro hilo antes de continuar.

Java tiene varios mecanismos para realizar ello.

* *Future*
* *CyclicBarrier*
* *Semaphore*
* *CountDownLatch*

<br>

# CountDownLatch - java.util.concurrent.CountDownLatch

> [CountDownLatch - doc](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html)

Puede tener una cuenta regresiva para que eventos significantes sucedan. Un hilo o hilos pueden esperar por todos estos eventos para completar antes de continuar.

**CountDownLatch**, es una barrera sincronizada. Las barreras son mecanismos para permitir que los hilos se coordinen con otros. Otros ejemplos son *CyclicBarrier* y *Phaser*.

Puedes tener una cuenta regresiva hasta tener una cantidad mínima de clientes o un número de servicios sean iniciados.

**java.util.concurrent.CountDownLatch**, establece un número para cuenta regresiva. Cualquier hilo le dice al contador cuando los eventos importantes sucedan.


```java
import java.util.concurrent.CountDownLatch;

class PredicableLatch {
	public static void main(String[] args) {
	
		ExecutorService executor = Executors.newSingleThreadExecutor();
		
		CountDownLatch latch = new CountDownLatch(1);
		
		executor.execute(() -> waitForLatchThenPrint(latch));
		
		System.out.println("back in main");
		
		latch.countDown();
		
		executor.shutdown();
		
	}
	
	private static void waitForLatchThenPrint(CountDownLatch latch) {
		try {
			latch.await();
		} catch (InterruptedExecution e) {
			e.printStackTrace();
		}
		
		System.out.println("to of the stack");
		
        //   se puede llamar a un metodo que tenga el código  ejecutar
	}
	
}
```

* Se crea un nuevo *CountDownLatch*, *envía una señal de espera*, entregando un valor en milisegundos.
* *executor.execute*, la expresión lambda se pasa el *CountDownLatch* instanciado al trabajo que se está ejecutando en un nuevo hilo.
* *latch.countDown()* le dice al contador que inicie después de imprimir el mensaje.
* *latch.await()* del método *waitForLatchThenPrint*, indica que se debe esperar al hilo para imprimir el mensaje. El hilo pasa a estado *non-runnable* mientras espera.
* *latch.await()* debe estar en bloque *try-catch*.


El uso de *CountDownLatch* o similares tiene un impacto en el significativo en el rendimiento.

En lugar de esperar 2 segundos para imprimir el mensaje, los nuevos hilos esperan hasta que el método principal imprima el mensaje.

Para hacer una idea, cuando se ejecuta este código 100 veces, tomará 50 milisegundos usando *CountDownLatch* o similares. Por otro lado, usando *sleep(2)* tomará 200331 milisegundos, es decir, unas 4000x veces más.

<br>

# Thread - resumen

* Cada hilo necesita de un trabajo, un trabajo puede ser una instancia de una clase que implemente interface **Runnable**.
* **Runnable** tiene un método que es *run()*, puede ser usado en una expresión lambda.
* Para crear programas Java multihilos se debe utilizar **ExecutorService** y **Executor**.
* **Executor** es una clase que ayuda a **ExecutorService** a iniciar nuevos trabajos.
* Un hilo está en un estado *NEW* cuando no se ha iniciado aún.
* Cuando se inicie, un nuevo *call stack* se inicia, con el método *.run()* de **Runnable** al final del stack.
* Cuando la JVM está ejecutando un hilo este tiene estado RUNNING. En procesadores de procesador único, puede ser un hilo ejecutado a la vez.
* Se puede mover de estados *RUNNING* al estado temporal *NON-RUNNABLE*, puede ser porque está esperando información entrante o porque está esperando el bloqueo de un objeto.
* El manejador de hilos no garantiza el trabajo de una manera en particular, no se puede tener certeza.

<br>

# ExecutorService - Executors

**ExecutorService** nos ayuda a iniciar un montón de trabajos independientes sin necesidad de crear un hilo por cada trabajo y no seamos responsables de tener seguimiento de todos esos hilos.

Diferentes implementaciones **ExecutorService** dependiendo de cuantos hilos necesitemos, podemos crear pools de *Thread*. Con esto nos permite reutilizar instancas *Thread*, sin pagar el costo de ello o iniciar cada vez nuevos hilos.

Por cada *Thread* creado, debemos de serguirlos para tener control sobre ellos. *Thread* te deja el trabajo de control a ti lo cual es un posiblemente un problema.

Aún se está usando *Thread* que ejecutará el trabajo.

Tienes que iniciarlos, detenerlos, y reusarlos si es necesario, es un trabajo considerable.

Gracias Java, acá entra en juego una interface y una clase del paquete **java.util.concurrent**:

* **java.util.concurrent.ExecutorService** (interface)
* **java.util.concurrent.Executors** (class)


**java.util.concurrent.ExecutorService**, interface que permite ejecutar trabajos **Runnables**, este crea, reusa, y mata hilos en orden de ejecución.

**java.util.concurrent.Executors**, clase con *métodos factory* para crear instancias **ExecutorService** cuando se necesiten.


*Executors* fue incorporado desde Java 5, para reemplazar el uso de *Thread* directamente, actualmente no existe necesidad de utilizarlos directamente.


Métodos *static factory* pueden ser usados en lugar de constructores.

Métodos *factory* retornan exactamente la implementación de una interface que necesitemos. No necesitamos conocer la clase concreta o saber cómo los creamos.


## ExecutorService - Executors - hilo único

```java
public class MyRunnable implements Runnable {

	public void run() {
		go();
	}
	
	public void go() {
		doMore();
	}
	
	public void doMore() {
		System.out.println(Thread.currentThread().getName() + ": top of the stack.");
		
		Thread.dumpStack();
	}
	
	public static void main(String[] args) {
		ClassThreadRunnable c = new ClassThreadRunnable();
		
		ExecutorService executor = Executors.newSingleThreadExecutor();  // solamente queremos iniciar un único trabajo, entonces, un único hilo.
		
		executor.execute(c);  // avisamos a ExecutorService
		
		
		System.out.println(Thread.currentThread().getName() + ": back in main");
		
		Thread.dumpStack();
		
		executor.shutdown();  //  se debe apagar el ExecutorService cuando se termine, sino, se queda esperando nuevos trabajos.
	}
}
```

<br>

## ExecutorService - Executors - multi-hilos

> [java.util.concurrent.Executors]()

Los siguientes *ExecutorServices* usan algunas formas de *thread pool*. Es una colección de instancias de hilos que pueden ser usados  y re-usados para realizar trabajos.

Cuántos hilo deben existir en el pool y qué se quiere hacer con ellos si existen trabajos disponibles depende de la implementación **ExecutorService**.

Para poder usar más de un hilo no se puede utilizar `Executors.newSingleThreadExecutor()`, en cambio debemos utilizar:

| Clase | Método | Descripción |
|-|-|-|
| ExecutorService | `.newCachedThreadPool()` | Crea un pool de hilos que crean nuevos hilos cuando se necesite, pero los podrá reutilizar los hilos ya existentes cuando estén disponibles. |
| ExecutorService | `.newFixedThreadPool(int nThreads)` | Crea un pool de hilos que reusan un numero de hilos sin utilizar que comparten fuera de un queue sin límites. |
| SheduledExecutorService | `.newSheduledThreadPool(int corePoolSize)` | Crea un pool de hilos que pueden manejar comandos para correr después de un tiempo de retardo, o ejecutarse periódicamente. |
| ExecutorService | `.newSingleThreadExecutor()` | Crea un *Executor* que usa un único hilo de trabajo que opera fuera de una cola (queue). |
| SheduledExecutorService | `.newSingleThreadSheduledExecutor()` | Crea un ejecutor de hilo-único que puede manejar comandos para ejecutar después de un retardo, o ejecutarse periódicamente. |
| ExecutorService | `.newWorkStealingPool()` | Crea un grupo de hilos que roban-trabajos usando un número de procesadores disponibles como objetivos de nivel paralelo. |

Estos tipos de *ExecutorService* usan algunas formas de *Thread Pool*, es una colección de instancias *Thread* que pueden ser usados y reusados para realizar trabajos.

Cuántos hilos están en el pool, y qué se harán si existen más trabajos que hilos disponibles, dependen de la implementación de **ExecutorService**.

<br>

## Pooling Threads

Usar un pool de recursos, especialmente uno que sean costosos para crearlos. Hilos o conexiones a base de datos, es un patrón común en código de aplicaciones.

1. Cuando se crea un nuevo pool **ExecutorService** se puede iniciar con algunos hilos al inicio o puede ser un pool vacío.

Utilizando la clase helper **Executors** podemos crear los pools de hilos.

```java
ExecutorService threadPool = Executors.newCachedThreadPool();
```

Un pool de hilos puede tener uno o más hilos, agregar, usar, reusar, manejar, matar hilos acorde a las reglas del pool.


2. Puedes usar el pool de hilos para ejecuatar trabajos entregandolo a **ExecutorService**, es este quien determinará si existen hilos libres para ejecutar el trabajo, reutilizando hilos.

```java
threadPool.execute(() -> run("Job 1");
```

Recordar que el trabajo puede ser una expresión lambda que use un método de clase o una clase *Runnable* que implemente el método *.run()*.


3. Al enviar más trabajos a *ExecutorService* este puede crear nuevos Threads para manejar los trabajos. Almacenarlos en un queue si existen más trabamos que Threads.

La forma de lidiar con esto, depende de la implementación  de *ExecutorService*.

```java
threadPool.execute(() -> run("Job 2312"));
```

*ExecutorService* puede también terminar Threads que estén sin hacer nada durante un tiempo, ayudando a minimizar el uso de recursos (RAM, cpu).

<br>

##  Cerrar el pool de hilos

Se debe cerrar el pool de hilos al finalizar el trabajo. **.shutdown()**, con esto los recursos que se usaron se liberan al sistema nuevamente.

**ExecutorService** tiene dos métodos para cerrar:

1. **ExecutorService.shutdown()**

*ExecutorService* es consultado si debe cerrar el pool, todos los trabajos en ejecución se terminan y los que estén esperando se finalizan, no recibirá nuevos trabajos.

Si se requiere que espere hasta que las cosas finalicen, se puede usar **ExecutorService.awaitTermination(nTiempo, unidadTiempo)**, es un tiempo máximo de espera.


2. **ExecutorService.shutdownNow()**

*ExecutorService* detiene todo en el momento. A veces es usado después de llamar *ExecutorService.shutdown()* dando la chance de terminar los trabajos antes de acabar con todo.

<br>

### Ejemplo de múltiples hilos

Este código corre dos trabajos, usando un pool de hilos de tamaño determinado usando el método de **Executors.newFixedThreadPool(n)**.

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class RunThreads {
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(2);
        threadPool.execute(() -> runJob("Job 1"));
        threadPool.execute(() -> runJob("Job 2"));
        threadPool.shutdown();
    }
    
    public static void runJob(String job) {
        for (int i = 0; i < 25; i++) {
            String threadName = Thread.currentThread().getName();
            System.out.println(job + " is running on " + threadName);
        }
    }
}
```

Qué pasa:
* Se crea un pool de 2 porque tiene 2 trabajos.
* La expresión lambda representa la ejecución del trabajo (puede ser una clase instanciada *Runnable*).
* La expresión lambda llama a un método que contiene un loop imprimiendo el nombre del hilo en cada iteración.

<br>

## Threads Resumen

*Threads* permiten realizar trabajos de forma más eficiente, pero existe un problema.

*Thread.sleep(milisegundos)*, fuerza al hilo a dejar de estar en estado *running* hasta que el tiempo termine. Debe estar en bloque `try/catch`.

*CountDownLatch* permite esperar un tiempo hasta que se notifique un evento que ha terminado el hilo anterior. Este mecanismo permite tener una forma de informar por medio de eventos el término de un hilo y no de un tiempo arbitrario estimado, demorando mucho menos tiempo en terminar el ciclo completo de ejecución.

Multihilos pueden desencadenar problemas de concurrencia y con ello a la **race conditions**, llevando a la corrupción de datos.

Al acceder al mismo recursos desde muchos hilos, realizando operaciones distintas podemos llevar a corromper los datos, accediendo desde distintos *stacks*.

Manejar hilos conlleva un montón de trabajo. **Executors** puede crear un **ExecutorService** y usarlo para ejecutar trabajos **Runnable**.

Los pool de hilos se pueden usar, reusar, destruir.

**ExecutorService** debe cerrarse cuando termine los hilos, mediante el uso de métodos como `shutdown()` que apaga todo de forma correcta, `shutdownNow()` cierra todo de forma abrupta.


<br>


\pagebreak


<br>


# ExecutorService - java.util.concurrent.ExecutorService

> [ExecutorService - doc](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html)

Un *Executor* provee métodos para administrar terminaciones y métodos para producir un seguimiento de `Future` del progreso en uno o más tareas asincrónicas.

`ExecutorService` puede ser apagado, rechazando nuevas tareas. Implementa interface `Executor` y el método `.execute(Runnable runnableTask)` retorna un `Future` para ser usado para cancelar la ejecución o esperar para su termino.

| Métodos | Descripción |
|-|-|
| `.execute(instanceRunnableClass)` | ejecuta el comando dado en alguna oportunidad en el futuro. Se puede ejecutar en un nuevo hilo, pool de hilos, o llamando a un hilo. |
| `.isShutdown()` | retorna booleano si el ejecutor se apagó. |
| `.isTerminated()` | retorna booleano si la tarea terminó. |
| `.shutdown()` | inicia ordenadamente el apagado, no acepta nuevas tareas. |
| `.shutdownNow()` | cierra todas las tareas, para el procesamiento de tareas y retorna la lista de taras que esperan ser ejecutadas. |
| `.submit(Runnable task)` | envía una tarea `Runnable` para ser ejecutada y retorna un `Future` que representa esa tarea. |

<br>

# Executors - java.util.concurrent.Executors

> [Executors - doc](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html)

Métodos y utilidades *Factory* para `Executor`, `ExecutorService`, `ScheduledExecutorService`, `ThreadFactory`, y `Callable`.

Permite:

* Crear y retornar `ExecutorService` y establecer configuraciones más usadas.
* Crear y retornar `ScheduledExecutorService` y establece configuraciones más usadas.
* Crea y retorna un `ExecutorService` envuelto, que deshabilita la pre-configuración y crea métodos inaccesibles de implementación específica.
* Crea y retorna un `ThreadFactory` que establece nuevos hilos creados para un estado conocido.
* Crea y retorna un `Callable` fuera de otras formas parecidos a un cierre, pudiendo ser ejecutadas en métodos que requieren `Callable`.


| Métodos | Descripción |
|-|-|
| `.newSingleThreadExecutor()` | crea un `Executor` que usa un hilo. | 
| `.newCachedThreadPool()` | crea un pool de hilo que crea nuevos hilos si se necesitan, pero puede reusar los hilos previamente construidos si están disponibles. |
| `.newFixedThreadPool(int nThreads)` | crea un pool de hilos con tamaño determinado. |
| `.newScheduledThreadPool(int corePoolSize)` | crea un grupo de subprocesos que puede programar comandos para que se ejecuten después de un retraso determinado o para que se ejecuten periódicamente. |

<br>

# Thread - java.lang.Thread

> [Thread - doc](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html)

Se debe instanciar una objeto **Thread** entregando como parámetro al constructor la instancia de la clase que implemente interface **Runnable**.

**Thread** no iniciará un nuevo hilo de ejecución hasta que se llame al método *.start()* en la instancia *Thread*.


```java
class PrimeThread extends Thread {

    long minPrime;
    
    PrimeThread(long minPrime) {
        this.minPrime = minPrime;
    }

    public void run() {
        // compute primes larger than minPrime
        . . .
    }
    
    public static void main(String[] args) {
    
        PrimeThread p = new PrimeThread(143);
        p.start();
        
    }
}
```

| Constructor | Descripción |
|-|-|
| `Thread()` | ubica un nuevo objeto `Thread`. | 
| `Thread(Runnable target)` | ubica un nuevo objeto `Thread`. |
| `Thread(Runnable target, String name)` | ubica un nuevo objeto `Thread`. |
| `Thread(String name)` | ubica un nuevo objeto `Thread`. |


| Métodos | Descripción |
|-|-|
| `.currentThread()` | retorna referencia a hilo en ejecución actual. |
| `.getname()` | retorna el nombre del hilo. |
| `.dumpStack()` | imprime la traza (huella) del stack del hilo actual para el stream estándar de error. |
| `.activeCount()` | retorna el numero estimado de hilos activos actuales. |
| `.getId()` | retorna el identificador del `Thread`. |
| `.getState()` | retorna el estado del hilo. |
| `.isInterrupted` | retorna booleano si el hilo se interrumpió.
| `.interrupted()` | booleano si el hilo es interrumpido o no. |
| `.interrupt()` | interrumpe el hilo. |
| `.isAlive()` | retorna booleano si el hilo está vivo. |
| `.isDeamon()` | retorna booleano si el hilo es un hilo demonio. |
| `.join()` | espera a que el hilo muera. |
| `.join(long milisegundos)` | espera milisegundos después que el hilo muere. |
| `.run()` | si el hilo fue construido usando `Runnable`, el método `.run()` es llamado, por otro lado, es inútil. |
| `.setDaemon(boolean on)` | marca el hilo como un hilo demonio. |
| `.setName(String name)` | establece nombre del hilo. |
| `.sleep(long milisegundos)` | duerme el hilo en milisegundos cesando la ejecución de forma temporal. |
| `.start()` | inicial la ejecución del hilo. |
| `.toString()` | retorna un String que representa al hilo. |


