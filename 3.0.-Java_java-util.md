# Java y java.util: Colecciones, Wrappers y Lambda expressions


## Java

Paquetes Java que son de muchísima utilidad, y son necesarias su conocimiento.

Contiene cientos clases preconstruidas, así que no necesitas reinventar la rueda si sabes qué necesitas y cómo usar la librería Java, conocida como **Java API**.

Es el core de Java, los cientos de clases de Java API.

* *[java.lang](https://docs.oracle.com/javase/8/docs/api/java/lang/package-summary.html)*
* *[java.util](https://docs.oracle.com/javase/8/docs/api/java/util/package-summary.html)*
* *[java.io](https://docs.oracle.com/javase/8/docs/api/java/io/package-summary.html)*



## java.lang


## java.util

Colección de frameworks, coleccion de clases lagadas, modelo evento, fecha y tiempo, internacionalización y clases de utilidad micelanea (un string tokenizer, generador de números aleatorios, un array bit).


## java.io





# Array - manual no generica

Es una serie de tipo de valores o conjunto de valores con los mismos tipos de datos.

Array puede almacenar referencias a objetos dentro de un array del mismo tipo de los datos referenciados.

Tiene operaciones limitadas, debido a que hay que implementarlas, pero se puede realizat tareas básicas como reemplazar por indice, acceder a datos, reemplazar datos.

Para crear un Array, se debe instanciar utilizando el tipo del valor más `[]`, asignar el tipo del dato, utilizando `new`, el tipo de dato y utilizar corchetes  con la cantidad de números que tendrá el Array.

Para ingresar los datos en el array creado, se debe utilizar el índice y asignar el dato.

```
		int[] array = new int[5];
		
		array[0] = 2;
		array[1] = 3;

		System.out.println(array[0]);
		
		for (int i = 0; i < array.length; i++) {
			System.out.println(array[i]);
		}
```

También se puede crear un Array de una forma más flexible, mediante el uso de `{ }` y los datos del mismo tipo.

```
int[] refs = {1,2,3,4,5};
```


Al crear un Array con datos primitivos, estos tomarán los valores por defecto de cada tipo de dato primitivo, es decir, un array **int** tendrá todos los valores por defecto en *0*, **char** en *\u0000*, String en *null*.

Al intentar acceder al índice fuera del tamaño del Array, dará error.

* Un array de tipo *Object* puede contener cualquier tipo de referencia.
* Cuando convertimos una referencia genérica a una referencia más específica, necesitamos usar un *type cast*.
* El *cast* solo compila cuando es posible, aún así puede fallar al ejecutarse.
* Cuando falla el *type cast*, podemos recibir un *ClassCastException*.
* Para recibir valores al llamar al programa Java en la línea de comando, podemos usar la matriz *String[]* en el método *main*.

Los argumentos de la línea de comando de Java se obtienen mediante el uso de *args* en el método **main(String[] args)** (args puede tener otro nombre).


## Métodos

`.clone()` - retorna un shadow copy de la instancia array.
`.equals(otraArray)` - comprueba si Arrays son iguales.
`.toString()` - lo convierte a String.
`.length` - retorna el tamaño del Array.


## type cast

En arrays con un distinto tipo de datos que los adminitidos, se debe cambiar su tipo usando la técnica de `type cast`.

Existe `type cast` **explícito** e **implícito**.

* **explícito**: declarar explícitamente el tipo de datos a convertir, debe tener relaciones entre las clases.

* **implícito**: no se declara, se puede omitir cuando los tipos de datos involucrados tienen relación hereditaria, ejemplo, `Cuenta unaCuenta = new CuentaAhorro(100);`.

Recordar que deben tener el mismo tipo de dato, en objetos, deben tener relaciones o utilizar `Object`.

```
Cliente clienteNormal = new Cliente();
clienteNormal.setNombre("Flavio");

Cliente clienteVip = new Cliente();
clienteVip.setNombre("Romulo");

Object[] refs = new Object[5];
Object refs[0]  = clienteNormal;
Object refs[1]  = clienteVip;

System.out.println(refs[1].getNombre());
```


En Java los objetos de Java son llamados **[Generics](https://www.geeksforgeeks.org/generics-in-java/)**.

El uso de Generics permiten optimizar el código escrito, evitar errores de compilación y estandarizar el código.



# Generics

[https://dev.java/learn/introducing-generics](https://dev.java/learn/introducing-generics)

Utilizando Generics, es posible crear clases que trabajen con diferentes tipos de datos.

Una entidad como clase, interfaz o método que opera en un tipo parametrizado es una entidad genérica.

Generics permite habilitar tipos (clases e interfaces) para ser parametizados cuando se están definiendo clases, interfaces y métodos.

La forma más común de parametizar es usado en declaraciones de métodos, tipos de parámetros proveen una forma de re-usar el mismo código con diferentes entradas.

Genéricos significa tipos parametrizados.

La diferencia es que las entradas de parámetros formales son valores, mientras las entradas por tipo parametizados son tipos.

La idea es permitir que el tipo (entero, cadena, etc., y tipos definidos por el usuario) sea un parámetro para métodos, clases e interfaces.  


## Por qué generics

El *Object* es la superclase de todas las demás clases, y la referencia de *Object* puede referirse a cualquier objeto. Estas características carecen de seguridad de tipo. Los genéricos agregan ese tipo de característica de seguridad.

Los genéricos en Java son similares a las plantillas en C++. Por ejemplo, clases como *HashSet*, *ArrayList*, *HashMap*, etc., usan genéricos muy bien. Existen algunas diferencias fundamentales entre los dos enfoques de los tipos genéricos.

Permiten una fuerte comprobación al momento de compilar. Un compilador Java aplica fuerte comprobación de tipo para código genérico y problemas si el código viola la seguridad de tipo.

Eliminación de casts o el casteo.

Permite a los programadores implementar algoritmos genéricos. Se puede implementar algoritmos genéricos que trabajan en colecciones de diferentes tipos, pueden ser personalizados y son de tipo seguro y fácil de leer.


## Tipos de genéricos de Java

* Método genérico: estáticos y no estáticos son permitidos, método genérico de Java toma un parámetro y devuelve algún valor después de realizar una tarea. Es exactamente como una función normal, sin embargo, un método genérico tiene parámetros de tipo que son citados por el tipo real. Esto permite utilizar el método genérico de una manera más general. El compilador se ocupa del tipo de seguridad que permite a los programadores codificar fácilmente, ya que no tienen que realizar largas conversiones de tipos individuales.

Método genérico incluyen listas de parámetros dentro de paréntesis dentro de *<>*.

Método estático genérico debe tener un *return*.


```
public class Util {
    public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
        return p1.getKey().equals(p2.getKey()) &&
               p1.getValue().equals(p2.getValue());
    }
}

public class Pair<K, V> {

    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    public K getKey()   { return key; }
    public V getValue() { return value; }
}
```

Utilizando métodos genéricos:

```
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.compare(p1, p2);
```


* Clases genéricas o interfaces: una clase genérica se implementa exactamente como una clase no genérica. La única diferencia es que contiene una sección de parámetros de tipo. Puede haber más de un tipo de parámetro, separados por una coma. Las clases que aceptan uno o más parámetros se conocen como clases parametrizadas o tipos parametrizados.

```
public class Box {
    private Object object;

    public void set(Object object) {
	    this.object = object;
    }
    public Object get() {
    	return object;
    }
}
```



* Clase genérica: Al igual que C++, usamos <> para especificar tipos de parámetros en la creación de clases genéricas. Para crear objetos de una clase genérica, usamos la siguiente sintaxis.

Con este tipo de clases podemos utilizar cualquier tipo de datos, debido a que todos los datos son heredados de *Object*.

Al declarar una clase parametizada mediante uso de *<T>* se está declarando que ahora puede ser cualquier objeto.

```
public class Box<T> {
    private T t;

    public void set(T t) {
    	this.t = t;
    }
    
    public T get() {
    	return t;
    }
}
```

> Nota: En el tipo de parámetro no podemos usar primitivas como 'int', 'char' o 'doble'.


* Funciones genéricas: También podemos escribir funciones genéricas que se pueden llamar con diferentes tipos de argumentos según el tipo de argumentos pasados al método genérico. El compilador maneja cada método.


## Los genéricos solo funcionan con tipos de referencia:

Cuando declaramos una instancia de un tipo genérico, el argumento de tipo pasado al parámetro de tipo debe ser un tipo de referencia. No podemos usar tipos de datos primitivos como `int`, `char`.

```
Prueba<int> obj = new Prueba<int>(20);
```

La línea anterior da como resultado un error de tiempo de compilación que se puede resolver usando contenedores de tipo para encapsular un tipo primitivo.

Pero las matrices de tipo primitivo se pueden pasar al parámetro de tipo porque las matrices son tipos de referencia.

```
ArrayList<int[]> a = new ArrayList<>();
```


## Convención de tipo en los genéricos de Java

Las convenciones de nomenclatura de parámetros de tipo son importantes para aprender a fondo los genéricos. Los parámetros de tipo comunes son los siguientes:

| Asignación | Descripción |
|-|-|
| E | Elemento - usado apliamente por Collections Java. |
| K | Clave |
| N | Número |
| T | Tipo |
| V | Valor |
| S, U, V, etc |  2nd, 3rd, 4th types parameters |



## Uso de Generics

Utilizando la clase genérica:

```
public class Box<T> {
    private T t;

    public void set(T t) {
    	this.t = t;
    }
    
    public T get() {
    	return t;
    }
}
```

Para crear una instancia de dicha clase utilizando un tipo de dato requerido.

```
Box<Integer> integerBox;
```

En este caso, la clase *Box* tiene el tipo de dato *Integer* reemplazando todas las *T* de la clase genérica a esta instancia.


Para inicializar la clase instanciada se requiere del uso del keyword *`new`*.

En versiones anteriores a Java SE 7 se debía declarar el tipo de datos entre *<>*, de la siguiente forma:

```
Box<Integer> integerBox new Box<Integer> ();
```

En versiones Java SE 7+, se puede omitir la declaración del tipo en la instancia porque Java lo hace automáticamente de forma implícita.

```
Box<Integer> integerBox new Box<> ();
```

Esto se llaman *notación diamante*.



## Multiple tipos de parámetros

Clases genéricas o Interfaces con múltiples parámetros deben utilizar por convención *K*, *V* para entregar parámetros.

```
public interface Pair<K, V> {
    public K getKey();
    public V getValue();
}

public class OrderedPair<K, V> implements Pair<K, V> {

    private K key;
    private V value;

    public OrderedPair(K key, V value) {
    this.key = key;
    this.value = value;
    }

    public K getKey()    { return key; }
    public V getValue() { return value; }
}
```


Utilizando el ejemplo anterior:

```
Pair<String, Integer> p1 = new OrderedPair<String, Integer>("Even", 8);
Pair<String, String>  p2 = new OrderedPair<String, String>("hello", "world");

OrderedPair<String, Box<Integer>> p = new OrderedPair<>("primes", new Box<Integer>(...));

```


## Tipos Crudos

Clases genéricas o Interfaces sin ningún tipo de argumento, se denominan *raw type*.

```
Box rawBox = new Box();
```


Son código legado anterior a JDK 5.0, usando *raw types* obtienes el comportamiento pre-genérico

Si asignas un *raw type* a un tipo parametizado, se obtendrá una advertencia:
```
Box rawBox = new Box();           // rawBox is a raw type of Box<T>
Box<Integer> intBox = rawBox;     // warning: unchecked conversion
```

De la misma forma obtendrás un error si intentas invocar un método genérico de una tipo genérico desde un tipo raw.

```
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
```

Se debería evitar el uso de *Raw Types*.


### Unchecked

Quiere decir que el compilador no tiene la información suficiente para realizar todas las comprobaciones necesarias para asegurar el tipo de forma segura.

Podemos suprimir la advertencia utilizando anotaciones, *[@SuppressWarnings("unchecked")](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/SuppressWarnings.html)*


## Ventajas de usar Generics

Los programas que usan `Generics` tienen muchos beneficios sobre el código no genérico.

1. Reutilización de código: podemos escribir un método/clase/interfaz una vez y usarlo para cualquier tipo que queramos.

2. Seguridad de tipos: los genéricos cometen errores que aparecen más en tiempo de compilación que en tiempo de ejecución (siempre es mejor conocer los problemas en su código en tiempo de compilación en lugar de hacer que su código falle en tiempo de ejecución). Suponga que desea crear una *ArrayList* que almacene el nombre de los estudiantes, y si por error el programador agrega un objeto entero en lugar de una cadena, el compilador lo permite. Pero, cuando recuperamos estos datos de *ArrayList*, causa problemas en tiempo de ejecución.

3. No se necesita la conversión de tipo individual: si no usamos genéricos, entonces, en el ejemplo anterior, cada vez que recuperamos datos de *ArrayList*, tenemos que encasillarlos. El encasillamiento en cada operación de recuperación es un gran dolor de cabeza. Si ya sabemos que nuestra lista solo contiene datos de cadenas, no necesitamos encasillarlos cada vez.

4. Los genéricos promueven la reutilización del código: con la ayuda de los genéricos en Java, podemos escribir código que funcionará con diferentes tipos de datos. Por ejemplo,

```
public <T> void genericsMethod (T data) {...}
```

Aquí, hemos creado un método genérico. Este mismo método se puede utilizar para realizar operaciones en datos enteros, datos de cadena, etc.

5. Implementación de algoritmos genéricos: mediante el uso de genéricos, podemos implementar algoritmos que funcionan en diferentes tipos de objetos y, al mismo tiempo, también son seguros para los tipos.



## Wildcards

Wildcards de símbolo *?*, representa un tipo desconocido, puede ser usado para relajar la restricción de un variable.

Por ejemplo, si se quiere utilizar un método para *List<Integer>*, *List<Double>*, *List<Number>*.


Tiene dos tipos de implementaciones:

1. Upper wildcard - por defecto, usando *?* y *extends*.
2. Lower wildcard - utilizando *?* y *super*.


### Upper wildcard

Se utiliza cuando no importe mucho sobre el tipo de genérico, porque acepta todos los subtipos de el tipo que se extiende.

Utilizando un wildcard y *extends* para clases e *implements* para interfaces, podemos realizar un uso de tipo de variables más flexible que utilizar algún tipo de dato declarado.

Esto permite el uso de la clase declarada y las clases que derivan de la clase declarada en el tipo.


Ejemplo de uso de Upper Wildcard.

```
List<Number>             // lista acepta solamente de tipo Number.

List<? extends Number>   // lista acepta cualquier tipo y subtipo de Number.
```



### Lower wildcard

Es representada por *?* seguido del keyword *super*, `<? super ClaseA>`.

> No se pueden usar ambos tipos de wildcard juntas.


Por ejemplo, implementar un método con mucha flexibilidad que pueda utilizar *List<Integer>*, *List<Number>*, y *List<Object>*, es decir, cualquier cosa que sea valor *Integer*.

```
public static void addNumbers(List<? super Integer> list) {
    for (int i = 1; i <= 10; i++) {
        list.add(i);
    }
}
```

Con esta implementación estamos usando un *lower wildcard*



### Wildcard Ilimitada

Utilizando solamente *?*, crea un método que recibe cualquier tipo, no tiene límites, es llamado de *tipo desconocido*.

Existen dos escenarios en dónde usar esto:

* Si se está escribiendo un método para ser implementado usando una funcionalidad de una clase *Object*.

* Cuando el código está usando métodos en clase genéricas que no dependen del tipo de parámetros, por lo que, *Class<?>* es más conveniente que *Class<T>*, en este caso.
Por ejemplo, *List.size()*, *List.clear()*.


*List<Object>* y *List<?>* no son lo mismo, debido a que el primero puede solamente insertar elementos *Object* en la lista, y en el segundo podemos insertar valores *null* solamente en esta lista.



### Wildcard y Subtipos

Podemos crear relaciones entre clases genéricas o interfaces.

Por ejemplo, tenemos dos clases regulares:

```
class A { /* ... */ }
class B extends A { /* ... */ }
```

Por lo que podemos escribir:

```
B b = new B();
A a = b;
```

Lo anterior es una herencia clásica de clases regulares siguiendo la regla de subtipo: clase B es un subtipo de A si B extiende A.


Esta regla NO aplica para tipos genéricos.

```
List<B> lb = new ArrayList<>();
List<A> la = lb;   // compile-time error
```


*Integer* es un subtipo de *Number* que tienen relación entre *List<Integer>* y *List<Number*.

```
           List<?>	  	
              |
    ---------------------------
    |                             |
List<Number>      List<Integer>
```


Porque *Integer* es un subtipo de *Number*, *List<Number>* no puede ser un subtipo de *List<Integer>*, porque no están relacionados. El padre común es *List<?>*.


Para poder crear una relación entre las dos clases para que puedan acceder a los métodos de *Number*, podemos usar *upper wildcard*:

```
List<? extends Integer> intList = new ArrayList<>();
List<? extends Number>  numList = intList;
// OK. List<? extends Integer> is a subtype of List<? extends Number>
```

Porque *Integer* es un subtipo de *Number* y *numList* es una lista de objeto *Number*, una relacion ahora existe entre *intList* y *numList*.


El diagrama siguiente muestra las relaciones de varias clases *List* declaradas con wildcard upper y lower.

```
                          List<?>
                              |
         --------------------------------------
         |                                           |
List<? extens Number>     List<? super Number>
List<? extens Integer>       List<? super Integer>
List<Integer>                       List<Number>
```



### Cuándo usar Wildcard

1. *Dentro* variable. Una variable *In* proporciona datos al código, ejemplo, un método *copy(src, dest)*, argumento *src* provee la información para ser copiado, entonces este es un parámetro *in*.

* Variables que estén usando *upper wildcard* utilizando keyword *extends*.


2. *Fuera* variable. Una variable *Out* mantiene la información que se usa en otra parte. En el ejemplo, *copy(src, dest)*, el argumento *dest* acepta la información, entonces es un parámetro *out*.

* Variables que estén usando *lower wildcard* utilizando keyword *super*.



En caso de necesitar acceso a variables *in* y *out* no usar wildcard.

**NO** aplicar en métodos para retornar un wildcard, al hacer esto fuerzas a los programadores a usar wildcards.



### Restricciones de Wildcard en Generics

* No se puede instanciar tipos genéricos con tipos primitivos.
* No se puede crear instancias de tipo parámetros.
* No se pueden declarar campos estáticos cuyos tipos son parámetros de tipo.
* No se puede usar Casts o instanceof con tipos parametrizados.
* No se pueden crear matrices de tipos parametrizados.
* No se pueden crear, atrapar o lanzar objetos de tipos parametrizados.
* No se puede sobrecargar un método donde los tipos de parámetros formales de cada sobrecarga se borran al mismo tipo sin formato.




\pagebreak

# Collection - java.util.Collection

**Collection**, es la **interface** de la jerarquía *collection*. Una collección representa un grupo de objetos, conocidos como *elements*.

Se debe tener claro la diferencia entre la interface *java.util.Collection* y la clase de *java.util.Collections*.

`Map` no extiende de interfaz *Collection*, pero se considera parte de framework *Collection*, con lo que, `Map` es todavía referido como una colección.

## Jerarquía Collection

```
Collection (interface)
|
|-- List (interface)
|        |
|        |- ArrayList  - implements List
|        |- LinkedList  - implements List
|        |- Vector  - implements List
|        
|-- Set (interface)  - extends Collection
|        |
|        |- SortedSet (interface)  - extends Set 
|        |          |
|        |          |- TreeSet  - implements SortedSet
|        |          
|        |- LinkedHashSet  - implements Set
|        |- HashSet  - implements Set
```

```
Map (interface)
|
|- SortedMap (interface)  - extends Map
|
|- HashMap  - implements Map
|- LinkedHashMap  - implements Map
|- HashTable  - implements Map
```



## Métodos - Collection

| Método | descripción |
|-|-|
| .stream() | retorna un *Stream* secuencial con las colecciones de la fuente. |
| .add(elemento) | agrega elemento y se asegura de agregarlo. |
| .addAll(Collection<?> c) | agrega coleccion a la coleccion dada. |
| .clear() | elimina todos los elementos de la colección. |
| .contains(Object o) | retorna booleano si existe elemento. |
| .containsAll(Collection<?> c) | retorna booleano si existe colección. |
| .equals(Object o) | compara objeto específico con la coleccion por igualdad. |
| .hashCode() | retorna el valor del hash code de la colección. |
| .isEmpty() | retorna booleano si la colección está vacía. |
| .iterator() | retorna un iterador sobre los elementos de la colección. |
| .parallelStream() | retorna posiblemente Stream paralelo con su colección como su fuente, recomendado para grandes cantidades de datos |
| .remove(Object o) | elimina la primera coincidencia del elemento en colección. |
| .removeAll(Collection<?> c) | elimina todas las ocurrencias del elemento en colección. |
| .removeIf(Predicate<?> filtro) | elimina elementos que coincidan con el filtro. |
| .retainAll(Collection<?> c) | retiene solamente elementos en su colección que estén contenidas en colección específica. |
| .size() | retorna el numero de elementos de la colección. |
| .spliterator() | crea Spliterator sobre los elementos en la colección. |
| .strem() | retorna Stream secuencial con su colección como fuente. |
| .toArray() | retorna un Array conteniendo todos los elementos en la colección. |
| .toArray(IntFunction<T[]> generator) | retorna un Array conteniendo todos los elementos en la colección, usando el generator para formatear los datos devueltos. |
| .toArray(T[] a) | retorna un array conteniendo todos los elementos de la colección, el tipo de dato es declarado en el tipo entregado. |
| .forEach(item -> {}) | itera en una coleccion.



# Collections - java.util.Collections

[https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)

[https://www.javatpoint.com/collections-in-java](https://www.javatpoint.com/collections-in-java)


**[Collections](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html)** es la superclase, exclusivamente con métodos estáticos que operan o retornan colecciones.

Algunas colecciones permiten elementos duplicados y otros no. Algunos son ordenados y otros no.

JDK no provee ninguna implementación directa de esta interface, esta provee implementaciones de subinterfaces más específicas como **Set** y **List**.

Esta interface es típicamente usado para pasar colecciones y manipularlas donde la generalidad máxima es deseada.

![](images/java-collection-hierarchy.png "Jerarquía - Collection")


## Métodos - Collections

[https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Collections.html#method-summary](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Collections.html#method-summary)

| Métodos | descripción |
|-|-|
| .addAll(Collection<?> c) | agrega todos los elementos a una colección especificada. |
| .binarySearch(List<?> list, TipeData key) | busca en lista por objeto usando búsqueda binaria. |
| .binarySearch(List<?> list, TipeData key, Comparator<?> c) | busca en lista por objeto usando búsqueda binaria. |
| .copy(List<?> destino, List<?> fuente) | copia todos los elementos de una lista a otra. |
| .fill(List<?> list, TipeData objeto) | reemplace todos los elementos de la lista con el objeto entregado. |
| .replaceAll(List<tipeData> list, T oldVal, T newVal) | reemplaza todas las ocurrencias. |
| .reverse(List<?> list) | revierte el orden de los elementos de lista. |
| .shuffle(List<?> list) | une aleatoriamente lista entregada usando una fuente aleatoria. |
| .shuffle(List<?> list, Random rnd) | une aleatoriamente lista entregada usando una fuente aleatoria. |
| .sort(List<TipeData> list) | ordena en orden ascendente, orden natural de los elementos. |
| .sort(List<TipeData> list, Comparator<?> c) | ordena acorde el comparador. |
| .swap(List<?> list, int i, int j) | intercambia posicion de elementos en lista entregada. |
| .rotate(List<?> list, int distance) | rota elementos en lista especificada por la distancia especificada. |
| .unmodifiableList(List<? extends T> list) | retorna una vista no-modificable de lista especificada. |
| .unmodifiableMap(Map<? extends K,? extends V> m) | retorna una vista no-modificable del map entregado. |
| .unmodifiableSet(Set<? extends T> s) | retorna una vista no-modificable set. |
| .unmodifiableSortedMap(SortedMap<K,? extends V> m) | retorna vista no-modificable de sorted map. |
| .unmodifiableSortedSet(SortedSet<T> s) | retorna vista no-modificable del sorted set entregado. |




## Collections Inmutable

Si se requiere que una colección no se modifique durante la vida de la colección, entran en juego las colecciones inmutables.

Estas no pueden se pueden agregar y eliminar elementos, incluso no se pueden cambiar de orden.

Java SE9 agregó a *List* y *Set* el método estático `.of()`.

`.of(elementos)`, recibe un grupo de elementos, retornando una estructura inmutable, no se puede agregar o eliminar elementos de la estructura.

No acepta valores *null*.

*Set* no permite duplicados.

La implementación que se obtiene es un **[Serializable](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/Serializable.html)**.

```
List<String> stringList = List.of("one", "two", "three");

Set<String> stringSet = Set.of("one", "two", "three");

Map<String, Integer> scores = Map.of("P1", 32,
                                                                     "P2", 23,
                                                                     "P3", 42);
```

Para *Map* de más de 10 entradas se debe utilizar *Map.ofEntries*.

```
Map<String, Integer> scores = Map.ofEntries(Map.entry("P1", 32),
                                                                                  Map.entry("P2", 23),
                                                                                  Map.entry("P3", 42));
```

## .unmodifiableList()

Envolver una *Collection* en una *Collection* inmutable.

El contenido no es duplicado, obtienes una estructura envuelta, todos los intentos de modificar dará error.

Pero si se modifica la colección original, este se reflejará en la colección no modificable.

```
List<String> strings = Arrays.asList("0", "1", "2", "3", "4");
List<String> immutableStrings = Collections.unmodifiableList(strings);
```



## Copia inmutable de una colección

Método `.copyOf()` de *List* y *Set* retornan una copia inmutable de los elementos.

```
Collection<String> strings = Arrays.asList("one", "two", "three");

List<String> list = List.copyOf(strings);
Set<String> set = Set.copyOf(strings);

```

La colección a copiar no debe ser *null* o contener elementos *null*.

`Set.copyOf()` si existen elementos duplicados solamente uno de esos elementos duplicados se mantienen.

Modificando esta colección no se reflejara en la lista o set original.

Ninguna de estas implementaciones aceptan valores *null*, entragará un [NullPointerException](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/NullPointerException.html).





# Stream - java.util.stream.Stream

[https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/stream/Stream.html](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/stream/Stream.html)

Permite convertir data en una colección.

*Stream* api se introdujo en Java 8

Crea un "stream" o "flujo" de una colección iterable, este secuencia los elementos soportando operaciones agregadas secuenciales y paralelo.

Para usar métodos *stream* debemos crear un stream.

El uso de `::` para acceder a los métodos es una práctica común, por lo que se recomienda usar esto en métodos como `.map()`.

Este se crea tomando una colección cualquiera y utilizar **.stream()**, podemos utilizar métodos de la api de *Stream*, utilizar varios seguidos (métodos encadenados).

```
int sum = widgets.stream()
                  .filter(w -> w.getColor() == RED)
                  .mapToInt(w -> w.getWeight())
                  .sum();
```

Los métodos se pueden encadenar para obtener resultados requeridos.

Métodos *Stream* que retornan otros *Stream* son llamados *Operaciones Intermedias*, son instrucciones de cosas para hacer, no realizan operaciones actualmente por si mismas.

Generics que pueden aparecer y su significado:

* <T> es usualmente el *Type* del objeto en el stream.
* <R> es usualmente el tipo de *Result* del método.


En resumen, **Stream** no almacena datos, simplemente son instrucciones de cómo llegar al resultado mediante operaciones intermedias y terminando en colecciones.

1. Se inicia con una colección y el uso de *.stream()*.
2. Operaciones intermedias, métodos propios de api **Stream**.
3. Salida de los datos del stream hacia alguna colección, mediante **.collect()**, **toList** u otra.


*Stream* es una tubería así como las tuberías en Linux. 

* Se necesita de un inicio y final una vez creado el stream.
* No se puede cambiar la colección durante la operación del stream.
* No se puede "guardar" datos del stream en operaciones intermedias, no se pueden reusar.
* **Stream** no cambian las colecciones originales.
* No existe límites de operaciones intermedias, se pueden usar tantas como se quieran.
* Para tener como resultado una colección sin modificar se debe utilizar *.collect(Collectors.toUnmodifiableList())*, *.collect(Collectors.toUnmodifiableSet())*, *.collect(Collectors.toUnmodifiableMap())*.
* Se puede guardar a **.toSet()**, **.toMap()** y sus contrapartes sin modificar.
* Si se requiere devolver algún campo del los objetos de un colección se debe utilizar **.map()** de **Stream**.




## Métodos - Stream

| Método | descripción |
|-|-|
| .allMatch(Predicate<?> predicate) | retorna todos los elementos del Stream que coincidan con el predicado entregado. |
| .anyMatch(Predicate<?> predicate) | retorna si algún elemento de esta secuencia coincide con el predicado proporcionado. |
| .count() | retorna entero del total de elementos del stream. |
| .distinct() | retorna un stream consistentemente de los elementos distintos. |
| .empty() | retorna un Stream secuencial vacío. |
| .filter(Predicate<?> predicate) | retorna un stream de todos los elementos coincidentes con el predicado, cumpla una entregado en una condición. (item -> item % 2 == 0) |
| .findAny() | retorna un Optional describiendo algun elemento del stream, o un Optional empty si el stream está vacío. |
| .findFirst() | retorna un Optional describiendo el primer elemento del stream, o un Optional vacío si el stream está vacío. |
| .orElseGet(() -> {}) | usado después de .findAny(), si no existe coincidencia se aplica la sentencia dentro de orElseGet debe retornar algo. |
| .forEach(item -> {}) | itera un stream. |
| .limit(tamaño) | retorna los elemento del stream cortados en el límite. |
| .map(Function<?> mapper) | retorna un stream consistentemente con el resultado aplicando la función entregada a los elementos. |
| .mapToDouble(ToDoubleFunction<?> mapper) | retorna un DoubleStream con todos los elementos del stream aplicando la funcion entregada. |
| .mapToInt(ToIntFunction<?> mapper) | retorna un IntStream con todos los elementos del stream aplicando la funcion entregada. |
| .mapToLong(ToLongFunction<?> mapper) | retorna un LongStream con todos los elementos del stream aplicando la funcion entregada. |
| .max() | retorna el elemento máximo. |
| .max(Comparator<?> comparator) | retorna el elemento máximo acorde al comparador. |
| .min() | retorna el elemento mínimo. |
| .min(Comparator<?> comparator) | retorna el elemento mínimo acorde al comparador. |
| .noneMatch(Predicate<?> predicate) | retorna cualquier elemento que no coincida con predicate. |
| .of(TipoDato t) | retorna un Stream secuencial conteniendo un único elemento. |
| .of(TipoDato valores) | retorna un Stream secuencial conteniendo todos los elementos especificados. |
| .ofNullable(TipoDato t) | retorna un Stream secuencia conteniendo un único elemento, si es no nulo, de otra forma retorna un Stream vacío. |
| .peek(Consumer<?> action) | retorna un stream consistentemente de los elementos del stream, adicionalmente realiza la acción provista en cada elemento con elemenetos consumidos desde el stream resultante. |
| .reduce(BinaryOperator<T> acumulator) | realiza una reduccion de elementos del stream, usando una función de acumulación asociativa, retorna un Optional describiendo el valor reducido, si lo hay. |
| .skip(long n) | retorna un stream con los elementos descartando los primeros n elementos. |
| .sorted() | retorna un stream ordenado de forma natural. |
| .sorted(Comparator<?> comparador) | retorna stream ordenado según comparador. Expresión Lambda. |
| .toArray() | retorna un array de los elementos del stream. |
| .toArray(IntFunction<A[]> generator) | Devuelve una matriz que contiene los elementos de esta secuencia, utilizando la función de generador proporcionada para asignar la matriz devuelta, así como cualquier matriz adicional que pueda ser necesaria para una ejecución particionada o para cambiar el tamaño. |
| .dropWhile(Predicate<? super T> predicate) | retorna, si el stream está ordenado, un stream con los elementos remanentes eliminados por el predicado, es una expresión lambda. |
| .takeWhile(Predicate<? super T> predicate) | retorna, si el stream está ordenado, un stream consistente al largo de elementos tomados por el strem que coincidan con el predicado entregado. |
| .toList() | retorna los elementos del stream en una List. |
| .collect(Collectors.toList) | retorna una lista de los elementos del stream. | 



---

* Ejemplo

Queremos ordenar una lista descendente por el tiempo de duración de Cursos con atributos que se llaman nombre y tiempo ¿Cuál sería la forma de poder hacerlo?


```
Curso curso1 = new Curso("PHP",30) ;
Curso curso2 = new Curso("Ruby",10) ;
Curso curso3 = new Curso("JavaScript",20) ;
Curso curso4 = new Curso("Java",50) ;


ArrayList<Curso> cursos = new ArrayList<>();
cursos.add(curso1);
cursos.add(curso2);
cursos.add(curso3);
cursos.add(curso4);


Collections.sort(cursos,Comparator.comparing(Curso::getTiempo).reversed());
```


Teniendo en consideración que la clase *Curso* tiene un método *getTiempo*.

---


# Optional  - java.util.Optional

[https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html)

**Optional**, es un contenedor de objetos, introducido desde Java 8, este puede o no contener valores *no nulos*.

Es un clase *basada en valores*, usa operaciones de identidad sensibles, incluyendo operador igualdad (==), identidad hash code o sincronización en instancias de *Optional* puede tener resultados impredecibles y deben ser evitados.

Si un valor está presente, método *.isPresent()* retorna *true* y *.get()* retorna ese valor.

Métodos adicionales que depende de la presencia o ausencia de un valor contenido son provistos, como *.orElse()* que retorna valor por defecto si no existe valores presentes, *.ifPresent()* ejecuta un bloque de código si el valor está presente.


```
Optional<Cancion> optional = listaCanciones.stream()
                                                                                .filter(song -> song.getTitle().equals("Los Simpsons")
                                                                                .findFirst();

if (optional.isPresent()) {

    Cancion cancion = optional.get();
    
} else {
    System.out.println("No encontrada");
}
```




## Métodos - Optional

| Método | Descripción |
|-|-|
| .empty() | booleano si está vacía la instancia Optional. |
| .equals(Object obj) | indica si el objeto es igual a otro. |
| .filter(Predicate<? super T> predicate) | si un valor está presente, y el valor coincide con el predicado entregado, retorna un Opcional describiendo el valor, por lo contrario, retorna un Optional vacío. |
| .get() | retorna el valor de instancia Optional. |
| .hashCode() | retorna hash code. |
| .ifPresent(Consumer<? super T> consumer) | si un valor está presente, invoca un consumidor específico con el valor, sino no hace nada. |
| .isPresent() | retorna booleano si tiene algún valor. |
| .map(Function<? super T, ? extends U> mapper) | si un valor está presente, aplica el mapa, si el resultado es un valor no nulo retorna un Opcional describiendo el resultado. |
| .of(T value) | retorna un Optional con el valor no nulo presente. |
| .ofNullable(T value) | retorna un Optional describiendo el valor específico si es NO nulo, de lo contrario retorna un Optional vacío. |
| .orElse(T otro) | retorna el valor si está presente, de otra forma retorna otro. |
| .orElseGet(Supplier<? extends T> otro) | retorna el valor si está presente, de otra forma invoca otro y retorna el resultado de esa invocación. |
| .orElseThrow(Supplier<? extends X> exceptionSupplier) | retorna el valor contenido, si está presente, de otra forma eleva una excepción para ser creado por el supplier  dado. |
| .toString() | retorna un string no vacío que representa Optional. |






# List - java.util.List

[https://docs.oracle.com/javase/8/docs/api/java/util/List.html](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)

**List**, coleccion ordenada (conocida como secuencia). El usuario debe controlar los tipos de datos que inserta a la lista. Puede acceder a los items por su índice y buscar elementos en la lista.

**List**, son muy usadas en el día a día.

Permite elementos duplicados (a diferencia de los *sets*),

**List** no se puede iniciar como **List**, es decir, no se puede iniciar un objeto List, se debe iniciar con una clase hija de *List* como un `ArrayList`, `LinkedList`, `Vector`.

**Utilizar si se quiere utilizar elementos determinados por su ubicación.**

Los datos son agregados a la lista mediante método `.add()`, o convertir un array en una `List` mediante `List<Integer> a = Arrays.asList(1,2,3,4);`.


## Sintaxis

* Forma Java 7+.
```
List<MyType> myList = new ArrayList<>();
```

* Forma Java7-.
```
List<MyType> myList = new ArrayList<MyType>();
```


## Métodos - List

| Métodos | descripción |
|-|-|
| .add(elemento) | agrega elemento al final del ultimo elemento. |
| .add(index, elemento) | agregar elemento a la lista. |
| .addAll(otraLista) | agrega todos los elementos de otraLista. |
| .clear() | elimina todos los elementos. |
| .remove(index) | elimina elemento desde su índice. |
| .remove(Object o) | elimina primera ocurrencia del elemento. |
| .removeAll(Collection<?> c) | elimina todos los elementos que coincida con la colección dada. |
| .contains(Object o) | retorna booleano si contiene elemento. |
| .containsAll(Collection<?> c) | retorna booleano si contiene todos los elementos de la colección dada. |
| .equals(Objet o) | compara el objeto entregado con la lista. |
| .get(index) | retorna elemento por índice. |
| .indexOf(Object o) | retorna índice de elemento. |
| .isEmpty() | retorna booleano si está vacío. |
| .set(index, elemento) | reemplaza elemento por su índice. |
| .size() | retorna numero de elementos de la lista. |
| .sort() | ordena Lista. |
| .sort(Comparator <?> c) | ordena según el comparador. |
| .toArray() | retorna un array con todos los elementos de la lista. |
| .toArray(TIPEDATA[] a) | retorna un array con todos los elementos de la lista formateado en el tipo de dato entreado. |




# ArrayList - java.util.ArrayList

[ArrayList](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html)
[ArrayList - w3s](https://www.w3schools.com/java/java_arraylist.asp)

**ArrayList**, array re-dimensionable.

Es recomendable utilizar wrappers de datos para uso de datos primitivos.

**ArrayList** es un array dinámico, es decir, que al alcanzar el límite, este vuelve a crear y conctenar los Array para aumentar su tamaño.

---

Por defecto no es *sincronizada*, si una instancia que utiliza un recurso **ArrayList** este debe sincronizarse externamente.

Para crear un **ArrayList** síncrono, se debe implementar al momento de la creación de dicha **ArrayList**.

```
List list = Collections.synchronizedList(new ArrayList(...));
```


No es la mejor opción, utilizar framework **Concurrent** en su lugar.

---


El constructor de **ArrayList** está sobrecargado, tiene un constructor que recibe un numero que indica el tamaño, y otro que recibe una lista esta la utiliza para ampliar la lista.

```
ArrayList<String> lista = new ArrayList(26); //capacidad inicial
lista.add("RJ");
lista.add("SP");
//otros estados

ArrayList<List> nueva = new ArrayList(lista);  //creando basada en la primera lista
```


## Sintaxis:

```
import java.util.ArrayList;

ArrayList<Tipodato> algo = new ArrayList<Tipodato>();
```

*Tipodato*: debe ser el objeto del tipo de dato, ejemplo, el objeto de **int** es **Integer**.
*Tipodato*: Fuerza a aceptar solamente utilizar todos los mismos tipos de datos.

```
ArrayList<Integer> algo = new ArrayList<Integer>();
```

Por defecto, crea una lista de 10 espacios por defecto.


## Métodos - ArrayList

* `.add(valor)` : agrega item después del último valor.
* `.add(index, valor)` : agrega item según el índice, indice no debe exceder el tamaño real de la lista.
* `.addAll(nuevaList)` : agrega una lista al final.
* `.clear()` : elimina todos los elementos.
* `.clone()` : retorna un shadow copy.
* `.contains(valor)` : retorna boleano si contiene valor.
* `.indexOf(item)` : retorna indice del item.
* `.remove(index)` : elimina item por índice.
* `.remove(Object o)` : elimina primera ocurrencia del elemento especificado.
* `.set(index, item)` : reemplaza item por su índice.
* `.size()` : obtiene el numero de elementos de la lista.
* `.get(indice)` : obtiene el item por su índice.
* `.forEach(item -> {iteracion item})` : iterar un Array.
```
		algo.forEach(item -> {
			if (item % 2 == 0) {
				System.out.println("--> " + item);
			}		
		});
```
* `.sort()`: ordena ArrayList.
* `.sort(Comparator<tipodato> c)`: ordena ArrayList mediante uso de comparador.

* Métodos declaradas en interface java.util.Collection

| Método | descripción |
|-|-|
| .stream() | retorna un *Stream* secuencial con las colecciones de la fuente. |


## Iterate ArrayList

**import java.lang.Iterable;**

Se necesita de un objeto [Iterable](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html), este permite iterar en un ArrayList.

Por ejemplo, un iterable de ArrayList devuelto desde un método.

```
Iterable<Cuenta> resultado = (Iterable<Cuenta>) arrayCuentas.getAllCuentas();

for (Cuenta cuenta: resultado) {
  System.out.println(cuenta);
}
```

Utilizando `.forEach()`
```
Iterable<Cuenta> resultado = (Iterable<Cuenta>) arrayCuentas.getAllCuentas();

resultado.forEach(item -> {
	System.out.println(item);
});
```



# Arrays - java.util.Arrays

[java.util.Arrays](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html)
[Arrays - Métodos](https://www.tutorialspoint.com/java/util/java_util_arrays.htm)

**Arrays**, contiene varios métodos para manipular varios Arrays.


Algunos métodos **Arrays**:

* `.binarySearch(array, item)`
* `.sort()` - Arrays, método sobrecargado.
* `.copyOf(array, inicioCopia)`
* `.copyOfRange(array, inicio, final)`
* `.equals(array, otherArray);`
* `.deepEquals(Object[] a1, Object[] a2)`
* `.asList(lista)`


Crear clases Array permiten tener acceso a métodos como ordenar, buscar, llenar el array, este extiende `Object`.

Tiene la sintaxis:

```
Arrays.método(arrays, [params]);

tipoDatoArray[] nuevo = Arrays.método(arrays, [params]);
```


## Envolver Array en un List

`Arrays` tiene cerca de 200 métodos para manejar arrays, mucho de estos implementan varios algoritmos como sorting, merging, searching, etc.

`Arrays.asList()`, este método toma como un array de elementos y retorna un **List**.

**[List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)** actúa como envolviendo un array y se comporta en la misma forma. Con esto podemos modificar un array.

Un array no permite redimensionarlo, es decir, agregar más elementos de los espacios establecidos, eliminarlos, o reducir el tamaño, por esto, se debe utilizar el método `.asList()` de la clase `Arrays`.


```
List<tipodato> unaLista = Arrays.asList(lista);
```

Ejemplo:
```
List<String> unaLista = Arrays.asList("UNO", "DOS", "TRES");
```



# LinkedList - java.util.LinkedList

[https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html)

[LinkedList](https://www.w3schools.com/java/java_linkedlist.asp)

**LinkedList**, en muchos casos es identico a **ArrayList**.

**En caso de duda, elija ArrayList.**

LinkedList comparados con otros Collections tiene un impacto en el rendimiento, es poco usado.

**LinkedList** almacena los items en "contenedores", la lista tiene un enlace al primer contenedor y cada contenedor tiene un enlace al sigiente contenedor de la lista.

Para agregar un elemento a la lista, el elemento es puesto en un nuevo contenedor y este contenedor es enlazado a otro contenedor en la lista.

---

**Cuando usar**

Usar un **ArrayList** para almacenar y acceder a la información, **LinkedList** para manipular información.

---


## Ventajas

* Inserción y eliminación con performance en cualquier posición, también al inicio.

* Acceso más lento por el índice, es necesario investigar los elementos.

## Desventajas

* Acceso fácil y de rendimiento por el índice.

* Los elementos deben copiarse cuando no hay más capacidad.



# Vector - java.util.Vector

[https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html](https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html)

> Actualmente es poco usado.

**Vector**, implementa objetos array ampliable, como un array, como array contiene componentes que puede ser acceido usando un índice entero, sin embargo, el tamaño de un `Vector` puede crecer o achicarse como se necesite para acomodarse agregando y eliminando items despues que el `Vector` sea creado.

Tiene un alto costo de redimiento.

Básicamente es igual a **List**, pero el **Vector** es **`Thread safe`**


---

## Thread safe

Java soporta multithreading fuera de la caja, es decir, ejecuta bytecode simultáneamente en hilos de workers, esto permite mejorar el rendimiento de aplicaciones en JVM.

Afectan al redimiento.

Es una gran capacidad, pero tiene un **costo**. En entornos de multi-threading se debe implementar una forma de asegurar los hilos, esto previene los errores en coportamiento y resultados no esperados. El uso del recurso en tiempo real evitando tener data no actualizada.

[https://www.baeldung.com/java-thread-safety](https://www.baeldung.com/java-thread-safety)


Por ejemplo, al ejecutar programaA y programaB estos están separados por sus hilos respectivos, ambos consumen el mismo recurso, pero programaA al editar el recurso, programaB no lo tiene actualizado, es decir, programaB tiene una versión antigua (programaA aún no guarda), y si empieza programaB a editar dicho recurso y lo guarda, el recurso tendrá un error de congruencia, debido a que los dos programas están editando en diferente períodos de tiempo.

Para evitar esto, existe los *thread safe*, **Vector** permite tener **Thread Safe**, esto es la gran diferencia con **List**.

---

Formas de crear un vector, según su constructor.

1. `Vector` vacío.
```
Vector()
```

2. Con colección de elementos.
```
Vector(Collection<?> c)
```

3. Vector vacío con una capacidad inicial.
```
Vector(int initialCapacity)
```

4. Vector vacío con capacidad inicial y cantidad de incremental.
```
Vector(int initialCapacity, int incrementalCapacity)
```


## Métodos - Vector

| Métodos | descripción |
|-|-|
| .add(elemento) | agrega elemento al final del ultimo elemento. |
| .add(index, elemento) | agregar elemento en indice del vector. |
| .addAll(Collection<?> c) | agrega todos los elementos de otra coleccion. |
| .addAll(index, Collection<?> c) | agrega todos los elementos de otra coleccion en una posicion determinada. |
| .capacity() | retorna la capacidad del vector. |
| .clear() | elimina todos los elementos. |
| .clone() | retorna un clon del vector. |
| .containsAll(Collection<?> c) | retorna booleano si contiene todos los elementos de la colección dada. |
| .ensureCapacity(int minCapacity) | forzar capacidad mínima del vector. |
| .equals(Objet o) | compara el objeto entregado con la lista. |
| .get(index) | retorna elemento por índice. |
| .forEach(item -> {item}) | itera Vector por cada elemento. |
| .firstElement() | retorna el primer elemento del Vector. |
| .lastElement() | retorna el último elemento del Vector. |
| .indexOf(Object o) | retorna índice de elemento. |
| .indexOf(Object o, index) | retorna índice de elemento por índice especificado, si no se encuentra elemento retorna *-1*. |
| .insertElementAt(objeto, index) | inserta elemento en posicon indicada. |
| .isEmpty() | retorna booleano si está vacío. |
| .lastIndexOf(Object o) | retorna el índice de la última ocurrencia del elemento entregado, *-1* si no contiene elemento. | 
| .remove(index) | elimina elemento desde su índice. |
| .remove(Object o) | elimina primera ocurrencia del elemento. |
| .removeAll(Collection<?> c) | elimina todos los elementos que coincida con la colección dada. |
| .removeAllElements() | elimina todos los elementos del vector. |
| .removeElement(Object obj) | elimina la primera ocurrencia con índice más bajo del vector. |
| .removeElementAt(index) | elimina elemento por índice. |
| .removeRange(fromIndex, toIndex) | elimina elementos desde índice inicial a uno final. |
| .set(index, elemento) | agrega elemento por índice. |
| .setSize() | establece el tamaño del vector. |
| .size() | retorna numero de elementos de la lista. |
| .sort() | ordena Vector. |
| .toArray() | retorna un array con todos los elementos de la lista. |
| .toArray(TIPEDATA[] a) | retorna un array con todos los elementos de la lista formateado en el tipo de dato entreado. |
| .toString() | retorna una representación String del Vector. |
| .trimToSize() | recorta la capacidad del vector, actualizando su capacidad actual. |

* Métodos declaradas en interface java.util.Collection

| Método | descripción |
|-|-|
| .stream() | retorna un *Stream* secuencial con las colecciones de la fuente. |




# Set - java.util.Set

[https://dev.java/learn/extending-collection-with-set-sortedset-and-navigableset/](https://dev.java/learn/extending-collection-with-set-sortedset-and-navigableset/)

[Set](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Set.html)

**Set**, interface no brindan ningún método nuevo de la interface *[Collection](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Collection.html)*, *Collections* entrega una implementación plana de la interface *Set*, esta es **[HashSet](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashSet.html)**(java.util.HashSet), internamente Hashset envuelve una interface de *[HashMap](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashMap.html)*, esta actúa como una delegada para *HashSet*.

**Set** prohíbe los datos duplicados, en comparación con *List*, **Sets** no tienen orden en particular, existe una poca probabilidad de iterar sobre estos en el mismo orden como fueron agregados al *set* utilizando una lista (*List*) de elementos y agregarlos al *Set*.

**Utilizar si se requiere elementos únicos.**


## Sintaxis

```
import java.util.HashSet;
import java.util.Set;

Set<String> algoSet = new HashSet<String>();
```


Recordar que el orden no está garantizado si se utiliza una lista y se agrega a un set.

```
List<String> lista = List.of("uno", "dos", "tres", "cuatro", "cinco");
		
<String> algoSet = new HashSet<String>();

algoSet.addAll(lista);
		
algoSet.forEach(item -> {
	System.out.println(item);
});
// cinco
// uno
// dos
// tres
// cuatro
```


## Métodos - Set

| Método | descripción |
|-|-|
| .add(elemento) | agrega el elemento. |
| .addAll(Collection<?> c) | agrega una coleccion completa al set. |
| .clear() | elimina todos los elementos del set. |
| .contains(Object o) | retorna booleano si el elemento existe en el set. |
| .copyOf(Collection<?> col) | retorna un Set Inmodificable de los elementos de la colección. |
| .equals(Object o) | compara objeto con el Set por igualdad. |
| .hashCode() | retorna el código hash del set. |
| .isEmpty() | retorna true si el Set está vacío. |
| .iterator() | retorna un iterator sobre los elementos del set. |
| .remove(Object o) | elimina elemento especificado desde el Set si este está presente. |
| .removeAll(Collection<?> c) | elimina desde el Set los elementos contenido en la coleccion entregada. |
| .retainAll(Collection<?> c) | retorna solamente elementos en el set que son contenidos en la colección entregada. |
| .size() | retorna el número de elementos en el Set. |
| .spliterator() | crea un Spliterator sobre los elementos del Set. |
| .toArray() | retorna un array con los elementos del Set. |
| .toArray(TipoDato[] a) | retorna un array con los elementos del Set, con el tipo de dato. |
| .forEach(iterator -> {}) | itera en un Set. |


* Métodos declaradas en interface java.util.Collection

| Método | descripción |
|-|-|
| .stream() | retorna un *Stream* secuencial con las colecciones de la fuente. |



## Extendiendo Set con SortedSet

La primera extension de *Set* es la interface **[SortedSet](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/SortedSet.html)**.

Interface *SortedSet* mantiene los elementos ordenados según cierta comparación lógica.

*Collections* entrean una implementación de *SortedSet* llamada **[TreeSet](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/TreeSet.html)**.

Se debe proveer un comparador cuando se construye un *TreeSet* o implementar una interface **[Comparable](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Comparable.html)** para los elementos puestos en *TreeSet*, si se usan ambos el comparador toma precedencia.


### Métodos - SortedSet

Tiene los métodos de *Set*, pero agrega algunos métodos más:

| Método | Descripción |
|-|-|
| .first() | entrega el primer elemento. |
| .last() | entrega el último elemento. |
| .headSet(toElement) | retorna un subset conteniendo elementos menores que toElement. |
| .tailSet(fromElement) | retorna un subset conteniendo elementos mayores que fromElement. |
| .subSet(fromElement, toElement) | retorna un subset de los elementos entre fromElement y toElement. |


Ejemplo de SortedSet:

```
SortedSet<String> strings = new TreeSet<>(Set.of("a", "b", "c", "d", "e", "f"));
SortedSet<String> subSet = strings.subSet("aa", "d");

System.out.println("sub set = " + subSet);
// sub set = [b, c]
```


Los tres subsets que estos métodos retornan son una *vista* del Set principal. No se realizó copias, cualquier cambio en estos subset se reflejará en el **Set** principal y en las demás.

Puedes eliminar, agregar elementos del **Set** principal por medio de los subset.

Hay que tener en cuenta, estos tres subset recuerdan los límites en los cuales fueron construídos, por esta razón, no es "legal" agregar un elemento por medio de un subset fuera de estos límites. Por ejemplo, si se toma un *[headSet](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/SortedSet.html#headSet(E))* y se intenta agregar un elemento mas grande que *toElement*, este devolverá un **[IllegalArgumentException](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/IllegalArgumentException.html)**.



# TreeSet - java.util.TreeSet

[https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html](https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html)

**TreeSet** es similar a *HashSet*, previene los duplicados, pero mantiene los items ordenados. Funciona como el método *.sort()* sin usar *Comparator*, utiliza el método *compareTo()* de cada objeto para ordenarlos. Se tiene la opción de pasar un *Comparator* al constructor *TreeSet*.

La desventaja es el impacto en rendimiento que tiene esta colección, pero para la mayoría de apps es casi no se nota.

Para ordenar **TreeSort** de forma diferente, se debe pasar un **Comparator** o una expresión lambda al constructor.


```
Set<Cancion> setCanciones = new TreeSet<>((o1, o2) -> o1.getYear() - o2.getYear());

setCanciones.addAll(listaCanciones);
```

Para poder usar **TreeSet**, se tiene dos formas de hacerlo:

1. Los objetos agregados a **TreeSet** deben implementar interfaz **Comparable** (método *.compareTo(Object o)*).

```
public class Cancion implements Comparable<Cancion> {
    private String title;
    
    public int compareTo(Cancion c1) {
        return title.compareTo(c1.getTitle());
    }
}
```


2. Se debe construir una clase **Comparator**, se instancia y se pasa al constructor de **TreeSet**.

```
class CancionCompare implements Compare<Cancion> {
    public int compare(Cancion o1, Cancion o2) {
        return o1.getTitle().compareTo(o2.getTitle());
    }
}

CancionCompare cancionCompare = new CancionCompare();
Set<Cancion> tree = new TreeSet<>(cancionCompare);
tree.add(...);
```



# HashSet - java.util.HashSet

[https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashSet.html](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashSet.html)

**HashSet**, no garantiza como el orden de la iteración del set, no garantiza el orden remanente constante sobre el tiempo. Esta clase permite elementos *null*.

**HashSet** vendría siendo similar a **ArrayList**, pero para *Set*.

Constructor de **HashSet** puede tomar como parámetro una lista, borrando duplicados.

Para borrar duplicados, `.hashCode()` si comprueba que tienen el mismo, verifica con `.equals()` si los objetos son duplicados realmente son iguales.

Al intentar agregar un objeto duplicado no se creará una excepción, el método `.add()` de HashSet retorna booleano, si se agrega retorna *true* de lo contrario retorna *false*, si retorna *false* se asume que el objeto ya está en el Set.


## Ejemplo de sobre-escritura .hashCode() - .equals()

Dentro de la clase, se debe sobre-escribir estos métodos.
En este caso se comparará los nombres de los títulos de los objetos

Si `title.hashCode()` tiene el mismo hashcode los dos objetos son iguales. Recordar que *String* hereda *.hashCode()* y lo sobre-escribe.

```
class Cancion implements Comparable<Cancion> {

    private String title;
// fields

    public boolean equals(Object song) {
        Cancion otra = (Cancion) song;
        return title.equals(otra.getTitle());
    }
    
    public int hashCode() {
        return title.hashCode();
    }


// compareTo

// constructor

// getters y setters
}
```


---

Esta implementación no es síncrona, si múltiples hilos acceden al set hash y alguno modifica el set, este debe sincronizarse externamente.

Si no existe el objeto, este debe "envolverse" usando el método **[Collections.synchronizedSet](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Collections.html#synchronizedSet(java.util.Set))**.

Esto se debe hacer al momento de crear el *HashSet*.

```
Set s = Collections.synchronizedSet(new HashSet(...));
```

No es la mejor opción, utilizar framework **Concurrent** en su lugar.

---


## Cuando usar HashSet

[https://www.baeldung.com/java-hashset-arraylist-contains-performance](https://www.baeldung.com/java-hashset-arraylist-contains-performance)

**HashSet** se debe utilizar para almacenar datos que únicos, permitiendo evitar tener duplicados y al momento de obtener los datos se tarda menos en encontrar lo buscado.

Para búsquedas más rápidas está **HashSet** utilizando `.contains()` es más rápido que usarlo en *List*, *ArrayList*, *LinkedList*.

```
Set<Canciones> cancioneSet = new HashSet<>();
```

De una lista a un hashset.

```
Set<Canciones> cancioneSet = new HashSet<>(listaDuplicados);
```

## Métodos - HashSet

| Métodos | descripción |
|-|-|
| .add(elemento) | agrega elemento al set si no está presente. |
| .clear() | elimina todos los elementos del set. |
| .clone() | retorna una shadow copy de la instancia HashSet, los elementos en si no son clonados. |
| .contains(Object o) | retorna true si contiene el elemento. |
| .isEmpty() | retorna true si el set no contiene elemento. |
| .iterator() | retorna interador sobre los elementos en el set. |
| .newHashSet(int numElements) | crea un nuevo, vacío HashSet para elementos numéricos. |
| .size() | retorna el número de elementos en el set. |
| .spliterator() | crea un late-binding (se une al origen de los elementos en el punto del primer recorrido, la primera división o la primera consulta de tamaño estimado, en lugar de en el momento en que se crea el Spliterator.) y fail-fast Splitoperator sobre los elementos del set. |
| .toArray() | retorna un array conteniendo todos los elementos en esa colección. |
| .toArray(TipoDato[] a) | retorna un array conteniendo todos los elementos de la coleccion, retornando con el tipo de valor entregado. |



# LinkedHashSet - java.util.LinkedHashSet

[https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashSet.html](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashSet.html)


**LinkedHashSet**, implementación tabla Hash y linked list de interface *Set*, con iteración con orden predictiva.

Mantiene una lista doblemente enlazada corriendo a través de todas las entradas, a diferencia de *HashSet*. Esta lista enlazadas define el orden de iteración la cual es el orden en que los elementos se han insertado (orden de inserción).

Notar que el orden de inserción no afecta si un elemento es re-insertado al set, un elemento es reinsertado dentro del set si `s.add(item)` es invocado cuando `s.contains(item)` retorna *true* inmediatamente antes de la invocación.

Esta implementación separa al cliente del caos de HashSet y del impacto negativo del rendimiento de *TreeSet*. 

Este puede ser usado para producir una copia que tenga el mismo orden del original.

```
void foo(Set<String> s) {
	Set<String> copy = new LinkedHashSet<>(s);
	...
}
```


Esto es realmente útil cuando el módulo toma un *Set* de entrada, lo copia, y retorna los resultados en orden determinado por el *Set* de entrada, (a los clientes les gusta tener las cosas de retorno en el mismo orden que los entregaron).


**LinkedHashSet** provee todos los métodos de *Set* y permite elementos *null*, los métodos de *HashSet*.

El costo en tiempo de una iteración de **LinkedHashSet** es proporcional a su capacidad, pero es menos costosa que iterar en *HashSet*.

El rendimiento es afectado por: *capacidad inicial* y *factor carga*, son definidas por *HashSet*. Pero aún así es menos alta la penalidad que utilizar *HashSet*.

---

Por defecto **no es síncrona**, si una instancia que utiliza un recurso **LinkedHashSet** este debe sincronizarse externamente.

Para crear un **LinkedHashSet** síncrono, se debe implementar al momento de la creación de dicha **LinkedHashSet**.

```
Set s = Collections.synchronizedSet(new LinkedHashSet(...));
```


No es la mejor opción, utilizar framework **Concurrent** en su lugar.

---

Los iteradores retornados son fail-fast, por lo que elevarán un *ConcurrentModificationException* si el set es modificado una vez que el *Iterator* es creado.

No está garantizado la alerta de iteradores *fail-fast*, solamente se deben utilizar para depurar el código.



## Métodos - LinkedHashSet

| Métodos | descripción |
|-|-|
| .newLinkedHashSet(int numElements) | crea una nueva, vacía plataforma LinkedHashSet con el espacio acorde al numero entregado. |
| .splititerator() | crea un late-binding y fail-fast Spliterator sobre los elementos del set. |

Contiene los métodos de *HashSet*, *AbstractSet*, *AbstractCollection*, *Object*, *Collection*, *Iterable*, *Set*.



\pagebreak


# Map - java.util.Map

[https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Map.html](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Map.html)

[https://dev.java/learn/using-maps-to-store-key-value-pairs/](https://dev.java/learn/using-maps-to-store-key-value-pairs/)

**Map** es una interfaz, hace parte del package *java.util* no posee métodos de la interfaz *Collection*, no hereda nada de *Collection*, pero se considera como parte del framework *Collection*. 

Trabaja bajo un concepto de (llave, valor).

* Tipo parámetro:
  * K - tipo de key mantenido por map.
  * V - tipo de value mapeado valores.
  
Esta clase usa la interfaz de la clase *Dicctionary*.

**Cuando se requiere acceder a elementos por `key`.**

Usar **Map** para obtener valores a través de una llave única, hace más rápido la búsqueda de información que en comparación de *List* o *Set*. Un mapa trabaja bajo un concepto de (llave, valor), al tener una llave única por ejemplo un DNI, termina siendo más rápido la búsqueda de información.

* Hashmap puede almacenar pares Key-Value
* key actuan como un símbolo para entregar valores.
* Key es un objeto cimple, un valor puede ser tan complejo como se necesite.
* key es único, value puede no ser único.
* Una key puede devolver multiples valores asociados.
* Elementos *null* no están permitidos.

Al cambiar el tipo de dato de una key este cambia su hash code, es decir, cambia su identidad, provocando que sea irrecuperable el par key-value que fue cambiado.




Interface **Map** tiene dos extensones, **SortedMap** y **NavigableMap**. *SortedMap* comparte la misma semática que *SortedSet*.

**SortedMap** ordenan los pares por el valor de key.


**HashMap** es ampliamente usado, pero existe otras dos implementaciones:

**[LinkedHashMap](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashMap.html)** es un *HashMap* con una estructura interna para mantener las llaves ordenadas.

**[IdentityHashMap](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/IdentityHashMap.html)** es un *Map* especializado que se debe usar en casos precisos, no es para uso general.

## Métodos Map

| Método | descripción |
|-|-|
| .put(key, value) | Agregar valores a un mapa se utiliza el método, si el par no existe en el mapa se agrega, si existe se reemplaza por el nuevo valor. Retorna *null*. |
| .putIfAbsent() | agrega kay/value al mapa si la llave no está presente y no tiene valores null asociados. |
| .get(key) | Obtener los valores de un mapa. |
| .remove(key) | Eliminar pares key/value mediante, retorna *null*. |
| .remove(key, value) | retorna un booleano, true si fue eliminado del mapa. |
| .containsKey(key) | comprobar keys y valores de un mapa. |
| .containsValue(value) | ambos retornan booleano. |
| .isEmpty() | retorna booleano si el mapa está vacio. |
| .size() | retorna la cantidad de pares key/value. |
| .clear() | elimina todo el contenido del mapa. |
| .putAll(otherMap) | agrega al mapa actual el contenido de otro mapa. |
| .keySet() | retorna set con las llaves, se puede eliminar keys mediante el índice de la key. |
| .values() | retorna una instancia Collection con los valores del mapa, se puede eliminar por su valor, elimina la primera concidencia del valor. |
| .replace(key, value) | reemplaza par key/value con nuevo valor. |
| .replace(key, oldValue, newValue) | actualiza par key/value con nuevo valor. |
| .forEach() | Iterar en un mapa mediante expresiones lambda. |

`.forEach((key, value) -> {
	System.out.println(key, value);
})`

## Sintaxis

```
Map<Object key, Object value> mapa = new HashMap<>();
```


### Ejemplo uso

El usar mapas es muy útil cuando tenemos registros únicos en nuestros registros como DNI, numero de celular, etc. Porque así podemos diferenciar nuestros valores y colocarlos como llave única en nuestros registros.

```
Map<String, Alumno> curos1 = new HashMap<> ();
curso1.put("008", new Alumno("Juan Miguel", "008") );
curso1.put("009", new Alumno("Maria Jose", "009") );
curso1.put("010", new Alumno("Luis Pedro", "010") );

curso1.forEach((codigo, alumno) -> {
    System.out.println(alumno);
});
```

## Mantener ordenado Map

[https://dev.java/learn/keeping-keys-sorted-with-sortedmap-and-navigablemap/](https://dev.java/learn/keeping-keys-sorted-with-sortedmap-and-navigablemap/)

**[SortedMap](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/SortedMap.html)**, implementa clase *[TreeMap](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/TreeMap.html)*.

**[NavigableMap](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/NavigableMap.html)**, implementa clase *[TreeMap](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/TreeMap.html)*.

*SortedMap* y *NavigableMap* necesitan de una forma que comparar las llaves, para ello tienes 2 soluciones:

* Comparar las llaves implementando *[Comparable](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Comparable.html)*.

* Proveer un *[Comparator](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Comparator.html)*.


Necesarios cuando se crean un *TreeMap*.

Si se utiliza un *SortedMap* o *NavigableMap* ambos son *TreeMap*, entonces puedes retornar un set usando *.keySet()* o *.entrySet()* para *SortedMap*, o *.navigableKeySet()* para *NavigableMap*.


*SortedMap* agrega los métodos:

* *.firstKey()* y *.lastKey()*: retornan el valor menor y el máximo del mapa.
* *.headMap(toKey)* y *.tailMap(fromKey)*: retornan un *SortedMap* de llaves menors a *toKey* y mayores o igual a *fromKey*.
* *.subMap(fromKey, toKey)*: retorna un *SortedMap* con llaves manores a *toKey* y mayores o igual a *fromKey*.


*NavigableMap* agrega los métodos:

* *.firstKey()*, *.firstEntry()*, *.lastEntry()*, y *.lastKey()*: retornan la entrada menor y mayor del mapa.

* *.ceilingKey(key)*, *.ceilingEntry(key)*, *.higherKey(key)*, *.higherEntry(key)* : retornan la llave menor o entrada mayor que la llave entregada. ceiling retorna la llave que es igual a key.

* *.floorKey(key)*, *.floorEntry(key)*, *.lowerKey(key)*, *.lowerEntry(key)* : retornan la llave mayor o menor que la key entregada.

* *.navigableKeySet()* : entrega un *NavigableSet* no necesita castear el resultado.

* *.descendingKeySet()* : retorna un *NavigableSet* del mapa con orden descendente.

* *.descendingMap()* : retorna un *NavigableMap* con la misma semántica.



## Métodos - Map

| Métodos | descripción |
|-|-|
| .clear() | eliminatodos los mapeos del map. |
| .containsKey(Object key) | retorna booleano si mapa contiene llave. |
| .containsValue(Object value) | retorna booleano si mapa contiene valor. |
| .copyOf(Map<Key, Value> map) | retorna un map inmutable. |
| .entry(K k, V v) | retorna map inmodificable conteniendo key y valor. |
| .entrySet() | retorna vista *Set* del mapeo contenido en el map. |
| .equals(Object o) | compara los objetos específicos con el mapa por igualdad. |
| .forEach(BiConsumer<? K, V> accion) | realiza accion por cada entrada del map. |
| .get(Object key) | retorna elemento por su llave. |
| .getOrDefault(Object key, V defaulValue) | retorna el valor de la llave mapeada, o si el mapa contiene defaultValue no mapeado de la llave. |
| .hashCode() | retorna código hash. |
| .isEmpty() | retorna booleano si está vacío. |
| .keySet() | retorna vista Set de las llaves del map. |
| .merge(K key, V value, BigFunction<? super V, ? super V,? extends V> remappingFunction) | especifica la llave si no está ya asociada con un valor o asociando con null, asocia con un valor no-nulo. |
| .of() | retorna un mapa inmutable conteniendo mapeado zero. |
| .of(K k1, V v1) | retorna un mapa inmutable conteniendo mapeo único. |
| .of(K k[2-10], V v[2-10], K k[2-10], V v[2-10], [2-10]) | retorna mapa inmutable conteniendo mapeo entre 2 y 10 Key y Value, dependiendo de la cantidad de (K k, V v). |
| .ofEntries(Map.Entry<?K, ?V> entradas) | retorna mapa inmutable conteniendo las llaves y valores extraídos de las entradas pasadas. |
| .put(K key, V value) | asocia el valor específico con la llave específica. |
| .putAll(Map<K, V> m) | copia todos los mapeos desde el mapa entrado. |
| .putIfAbsent(K key, V value) | si la llave no está asociada al valor o mapea nulo retorna null, sino retorna el valor actual. |
| .remove(Object key) | elimina el mapeo según la key entragada y si está presente. |
| .remove(Object key, Object value) | elimina el mapeo según key y value entregada. |
| .replace(K key, V value) | reemplaza solamente si la key está mapeado con el valor entregado. |
| .replaceAll(BiFunction<?K, ?V> function) | reemplaza cada entrada con el valor del resultado invocado por la funcion hasta que todos los valores sean reemplazados o de lo contrario dará una excepción. |
| .size() | retorna cantidad key-value del map. |
| .values() | retorna una Collection view de todos valores del map. |



# HashMap - java.util.HashMap

[https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashMap.html](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashMap.html)

**HashMap**, tabla Hash basado en implementación de interface Map. Provee todas las operaciones de Map, permite valores *null* y llaves *null*.

HashMap es apenas equivalente a HashTable, excepto que HashMap no es síncrono y permite nulls.

* Tipo parámetro:
  * K - tipo de key mantenido por map
  * V - tipo de value mapeado valores


No garantiza el orden del mapa, ni que el orden se mantenga a lo largo del tiempo.

Permite realizar operaciones constante en el tiempo como *get* y *put*.

Iteracion sobre las vistas de colección requieren tiempo acorde a la capacidad de HashMap. Es importante establecer una capacidad inicial no tan alta o con factor de carga baja, si el rendimiento de iteración es importante.

**HashMap** le afectan dos factores: capacidad inicial y factor de carga. Capacidad el el número de slots en la tabla hash, y la capacidad inicial es la capacidad cuando se crea la tabla hash. Load Factor es el promedio de como la tabla hash permite obtener antes que la capacidad sea automáticamente incrementada.

Tiene factor de carga de *.75* por defecto.

Esta implementación no es sincrona se debe utilizar `Collections.synchronizedMap`:

```
Map m = Collections.synchronizedMap(new HashMap(...));
```

Los iteradores retornados son fail-fast, por lo que elevarán un *ConcurrentModificationException* si el set es modificado una vez que el *Iterator* es creado.

No está garantizado la alerta de iteradores *fail-fast*, solamente se deben utilizar para depurar el código.


## Métodos - HashMap

| Método | Descripción |
|-|-|
| .clear() | elimina todos los items. |
| .clone() | retorna una shadow copy de la instancia HashMap. |
| .compute(K key, BiFunction<? K, ? V> remappingFunction) | intenta computar un mapeo por la llave específica y retorna el valor actual del mapa o null. |
| .computeAbsent(K key, Function<? K, ?V> remappingFunction) | si la llave no tiene el valor asociado o retorna null, intenta calcular el valor usando funcion map e introduce si NO es nulo. |
| .computeIfPresent(K key, BiFunction<? K, ? V> remappingFunction) | si el valor de la llave está presente y no es nulo, intenta calcular un nuevo mapeo entregando la llave y el valor actual del mapeo. |
| .containsKey(Object key) | retorna true si el mapa contiene la llave específica. |
| .containsValue(Object value) | retorna true si el mapa contiene una o más llaves con el valor. |
| .entrySet() | retorna vista Set del mapeo del conteniendo en este map. |
| .get(Object key) | retorna el valor con el cual la llave entregada es mapeada, o null si este mapa no contiene la llave mapeada. |
| .isEmpty() | retorna true si mapa está vacio. |
| .keySet() | retorna vista Set de las llaves del mapa. |
| .merge(K key, V value, BiFunction<? V> remappingFunction) | si la llave asociada no tiene el valor entregado o si es null, este lo asocia a un valor no nulo. |
| .newHashMap(int numMappings) | crea un nuevo, vacio HashMap por el número esperado de mapeo. |
| .put(K key, V value) | ingresa key-value al map. |
| .putAll(Map<?K ,? V> m) | copia todas las key-value del mapa. |
| .remove(Object key) | elimina el mapeo usando la llave entregada. |
| .size() | retorna el número par key-value del mapa. |
| .values() | retorna una vista Collection de los valores del mapa. |



# LinkedHashMap - java.util.LinkedHashMap

[https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashMap.html](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashMap.html)


**LinkedHashMap**, es una combinacion entre Hash table y linked list implementando interface Map, tiene orden predictivo de iteración.

* Tipo parámetro:
  * K - tipo de key mantenido por map
  * V - tipo de value mapeado valores


**LinkedHashMap** mantiene lista doble enlazada ejecutándose a través de todas las entradas. Tiene iteración ordenada que está normada en el orden que son insertados los pares keys-value al mapa (orden de inserción).

Notar que el orden de inserción no afecta si un elemento es re-insertado al mapa, un elemento es reinsertado dentro del set si `s.add(item)` es invocado cuando `s.contains(item)` retorna *true* inmediatamente antes de la invocación.

Se puede utilizar para crear una copia de la original.

```
void foo(Map<String, Integer> m) {
	Map<String, Integer> copy = new LinkedHashMap<>(m);
	...
}
```

Esta técnica es usada para copiar un mapa, y retornarla de forma ordenada.

---

**No es una implementación sincrona**, se debe utilizar `Collections.synchronizedMap` al momento de crearla.

```
Map m = Collections.synchronizedMap(new LinkedHashMap(...));
```

---


Los iteradores retornados son fail-fast, por lo que elevarán un *ConcurrentModificationException* si el set es modificado una vez que el *Iterator* es creado.

No está garantizado la alerta de iteradores *fail-fast*, solamente se deben utilizar para depurar el código.


## Métodos - LinkedHashMap

| Método | Descripción |
|-|-|
| .clear() | elimina todo del mapa. |
| .containsValue(Object value) | retorna true si tiene una o más veces el valor en el mapa. |
| .entrySet() | retorna una vista Set del contenido del mapa. |
| .get(Object key) | retorna el valor de la llave o retorna null. |
| .keySet() | retorna una vista Set de las llaves del mapa. |
| .newLinkedHashMap(int numMappings) | crea una nueva, vacia LinkedHashMap con el tamaño del úmero entregado. |
| .removeEldesEntry(Map.Entry<K, V> eldest) | retorna true si el mapa debe eliminar entrada eldest. |
| .values() | retorna vista Collections de los valors del mapa. |



# Random - java.util.Random

[https://docs.oracle.com/javase/8/docs/api/java/util/Random.html](https://docs.oracle.com/javase/8/docs/api/java/util/Random.html)

Una instancia genera un strem de números pseudo aleatorios.

Utiliza una seed de 48-bit, utiliza fórmula lineal congruente.

Muchas aplicaciones simplemente usan *Math.random()*.

Es threadsafe, multiples uso consecutivos puede incurrir en desempeño bajo. En este caso, utilizar [ThreadLocalRandom](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadLocalRandom.html) para diseños multi-hilos.

No es criptográficamente seguro, utilizar en su lugar [SecureRandom](https://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html) para utilizar un generod de número pseudo aleatorios criptográficamente seguro para información sensible.

## Constructor

```
Random random = new Random();

//

int seed = 12314;
Random random = new Random(seed);
```

## Métodos - Random

| Método | Descripción |
|-|-|
| .nextInt(numero) | retorna un int pseudorandom siguente, uniformemente distribuido desde el generador, entre 0 y un número. |
| .nextFloat(numero) | retorna un float pseudorandom siguente, uniformemente distribuido desde el generador, entre 0 y un número. |
| .nextDouble(numero) | retorna un double pseudorandom siguente, uniformemente distribuido desde el generador, entre 0 y un número. |
| .nextLong(numero) | retorna un float pseudorandom siguente, uniformemente distribuido desde el generador, entre 0 y un número. |
| .nextBoolean() | retorna un boolean pseudorandom siguente, uniformemente distribuido desde el generador. |
| .ints() | retorna un strem ilimitado de valores int. |
| .longs() | retorna un strem ilimitado de valores long. |
| .doubles() | retorna un strem ilimitado de valores doubles. |
| .setSeed(long seed) | establece un seed para el generador. |
















\pagebreak



# ArrayList vs HashSet

[https://www.java67.com/2012/07/difference-between-arraylist-hashset-in-java.html](https://www.java67.com/2012/07/difference-between-arraylist-hashset-in-java.html)

La principal diferencia entre *ArrayList* y *HashSet* es que la primera es una implementación *List*, mientras que la segunda es una implementación *Set*.

Todas las diferenias radican en la estructura que posee.

*List* permite el acceso aleatorio por índice, los elementos están ordenados al momento de agregarlos.

*Set* no permite el acceso aleatorio por índice, no garantiza el orden de los elementos agregados.


En ambos debemos interar para obtener los datos de todos los elementos.

*ArrayList* y *HashSet* son subclases de *Collection*.


## Similitudes entre ArrayList y HashSet

1. Ambos son colecciones **NO Sincronizadas** y no están destinados a ser usados en entornos concurrentes y de subprocesos múltiples.

Para crearlos de forma sincronizada se debe utilizar `Collections.synchroinzedCollection()`.

No es la mejor opción, utilizar framework **Concurrent** en su lugar.

2. Ambos pueden ser iterados usando *Iterator*, esta es la forma correcta de realizar operaciones para todos los elementos.

3. Ambos son fail-fast, por ejemplo, elevarán un *ConcurrentModificationException* si *ArrayList* o *HashSet* son modificados una vez que el *Iterator* es creado.


## Diferencias entre ArrayList y HashSet

1. La primera y más importante diferencia entre *ArrayList* y *HashSet* es que *ArrayList* implementa la interfaz *List* mientras que *HashSet* implementa la interfaz *Set* en Java.

2. Otra diferencia entre *ArrayList* y *HashSet* es que *ArrayList* permite duplicados mientras que *HashSet* no permite duplicados. Este es el efecto secundario de la primera diferencia y la propiedad de implementar la interfaz *List* y *Set*.

3. Las diferencias entre *ArrayList* y *HashSet* es que *ArrayList* es una colección ordenada y mantiene el orden de inserción de los elementos, mientras que *HashSet* es una colección desordenada y no mantiene ningún orden.

4. La diferencia entre *ArrayList* y *HashSet* es que *ArrayList* está respaldado por un *Array* mientras que *HashSet* está respaldado por una instancia de *HashMap*.

5. La quinta diferencia entre *HashSet* y *ArrayList* es que está basado en índices, puede recuperar objetos llamando a `.get(index)` o eliminar objetos llamando a `.remove(index)` mientras que *HashSet* está completamente basado en objetos. HashSet tampoco proporciona el método `.get()`.








# Ordenando Datos - sorting

Java usa *Unicode*, el orden se realiza de la siguiente forma:

* números se ordenan antes que las letras mayúsculas.
* letras mayúsculas antes que las minúsculas.
* algunos carácteres especiales se ordenan antes que los números y otros se ordenan después de los números.

---

**NO** se pueden ordenar valores `null`.

---

Ordenamiento natural sirve para ordenar Strings.

Para ordenar Objetos se debe utilizar clases que extiendan `Comparable` o `Comparator`.

En cada tipo, si está disponible, se puede ordenar mediante uso de *Comparator* y comparar dos tipos de *Object*.

Interfaces **Comparable** (java.lang.Comparable) y **Comparator** (java.util.Comparator) son las que se usan para definir los criterios de orden en una lista.

* Interface `Comparable` define orden natural de elementos, método `.sort()` de la clase que necesita orden, (manera antígua).
Es decir, que la propia clase define los propios criterios de ordenación implementando `java.lang.Comparable`.

* Interface `Comparator` es el parámetro del método `.sort()` de la lista y clase *Collections*, (manera moderna).


En resumen, lo destacable es:

* `Collections.sort(List lista)` y * `List.sort(Comparator c)` hacen lo mismo,  se puede elegir cual utilizar.
 
* `List.sort` se introdujo en Java 8, códigos previos se debe usar `Collections.sort`.


* `Collections.sort(List lista)`, compara los elementos de la lista usando método *.compareTo()*, este método debe ser implementado en una clase que implemente *Comparable*.

* `List.sort(Comparator c)`, o `Collections.sort(List lista, Comparator c)`, usarán el método *.compare()* de **Comparator**, no necesita implementar interface *Comparable*, pero si se hace el método *.compareTo()* no será llamado.


## Interface Comparable<T>

Se compara dos elementos de una lista, el propio elemento y otro que es el parámetro, todo dentro de la misma clase.

* `.compareTo(Objeto otro)`.

Usando *.sort()* entregando el comparador para ordenar según el criterio del comparador. 

# Ejemplo implementación Comparable

Se define el método `.compareTo(Object otro) {}` en la propia clase, retorna un *int*.

```
class SongV3 implements Comparable<Songv3> {
    // fields
    
    public inf compareTo(SongV3 otherSong) {
        return title.compareTo(otherSong.getTitle());
    }
    
    // constructor
    // getters and setters
}
```

```
Collections.sort(listaSonsv3);  // orden natural
```


## Interface Comparator<T>

Es una clase que implementa *Comparator* implementa el método:

* `.compare(T o1, T o2);`

Al usar `.sort()` el orden es determinado por *Comparator*. Si no se pasa un *Comparator*  y el elemento es *Comparable* el método `.sort()` se ordena determinado por el método *.compareTo()*.

# Ejemplo implementación Comparator

Recordar que `Comparator` usa método `.compare(Object a, Object b) {}`.

En el método se puede usar `.compareTo()` del tipo de dato *String*, retornando *int*.

```
class TitleCompare implements Comparator<SongV3> {
    
    public int compare(Song one, Song two) {
        return one.getTitle().compareTo(two.getTitle());
    }
    
}
```

```
TitleCompare titleCompare = new TitleCompare();
songList.sort(titleCompare);

Collections.sort(songList,new TitleCompare());  
```



## Post Java 1.8

Las clases, wrappers, interfaces, tienen métodos de implementación *sort()*, se puede utilizar *Comparator* para comparar los valores y ordenar las colecciones.

### uso de Comparator en .sort()

[https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html)

Funciona retornando valores -1,  0, 1 acorde a la lógica de comparación.

Comparando tipos numéricos se puede, además, resta los dos valores de los objetos porque el resultado de la resta puede ser 0, positivo o negativo.

Utilizar wapper `Integer.compare(numero1, numero2)`.


### Creando custom comparador Objetos

Se debe crear una clase utilitaria que implementará la interface *Comparator<tipoDato>* sobreescribiendo el método *compare* que recibe dos objetos para compararlos.

Estos al ser:
* igual retorna 0.
* mayor que retorna 1.
* menor que retorna -1.


# Ejemplo de clase Comparator
```
class OrdenadoPorCuenta implements Comparator<Cuenta> {

	@Override
	public int compare(Cuenta o1, Cuenta o2) {
		if (o1.getNumeroCuenta() == o2.getNumeroCuenta() {
			return 0;
		} else if (o1.getNumeroCuenta() > o2.getNumeroCuenta() {
			return 1;
		} else {
			return -1;
		}
	}
	
}
```

### String - custom comparador

String podemos comparar dos string y utilizar dicho método para usarlo en el ordenamiento de la colección.

```
class OrdenadoPorNombre implements Comparator<Cuenta> {

	@Override
	public int compare(Cuenta o1, Cuenta o2) {
		return o1.getTitular().getNombre().compareTo(02.getTitular().getNombre());
	}
	
}
```

Para utilizar dicho comparador de String, se debe instanciar y utilizar en la lista como parámetro de método *.sort()*.

```
Comparator<Cuenta> comparador = new OrdenadoPorCuenta();

lista.sort(comparador);
```


## Pre Java 1.8

Orden natural, en sistemas con versiones de Java 1.8, se puede implementar ordenamiento en Java.

Las clases que quieran ordenarse se deben **implements** la clase **Comparable<?>**, a **Comparable** se le debe pasar el tipo de dato (la de la clase misma o de lo que se requiera comparar. Implementar el método `.compare(Object o1, Objecto2)` en la clase que implementa **Comparable**.

Se debe declarar el *orden natural* (orden por defecto) para que **Comparable** pueda saber cómo ordenar la colección de datos de esta clase.


### implements Comparable

En la clase que se quiera ordenar implementar interface **Comparable**.
Tiene solamente un método `compareTo(Object obj)` se puede implementar utilizando:

* if/else
* restando numeros
* utilizando wrappers que comparen los elementos (String.compareTo(), Integer.compare(), etc).

```
public abstract class Cuenta implements Comparable<Cuenta> {

    Integer agencia = 0;
	// [ ... ]
	
	public int compareTo(Cuenta obj) {
		// Orden natural. Orden por defecto que hará Comparable
		return Integer.compare(this.agencia, obj.getAgencia());
	}
	
}
```


Este *compareTo* compara la agencia del objeto actual con otro objeto que se le entrega.


### Usando sort implementado

Se debe utilizar la clase **Collections.sort()**

`Collections.sort()` ordena lista especificada acorde el comparador.


Comparando los dos métodos de ordenamiento, mediante interface (actual forma) o orden natural (forma legado).

```
class OrdenadoPorNombre implements Comparator<Cuenta> {

	@Override
	public int compare(Cuenta o1, Cuenta o2) {
		return o1.getTitular().getNombre().compareTo(02.getTitular().getNombre());
	}
	
}
```

```
// Utilizando Interface
Collections.sort(lista, new OrdenadorPorNombre());


// Forma antigua - Orden Natural
Collections.sort(lista);
```

Este lo hará de forma natural para el objeto, es decir, por defecto, que está declarado en la clase *Cuenta* en su método *compareTo(Cuenta o)*.



# .sort() y Clases anónimas

Ejemplo de clase anónima, ordenar una lista de elementos dentro de un método `.sort()`.


## Usando .sort() de forma moderna

```
import java.util.Comparator;
import java.util.ArrayList;

ArrayList<Integer> lista = new ArrayList<>();
lista.add(5);
lista.add(2);
lista.add(3);
lista.add(1);
lista.add(4);


//  clase anónima
lista.sort(new Comparator<Integer>() {
			
	public int compare(Integer o1, Integer o2) {
		if (o1 == o2) {
			return 0;
		} else if (o1 > o2) {
			return 1;
		} else {
			return -1;
		}
	}
	
});
		
System.out.println(lista);
//  [5, 2, 3, 1, 4]
//  [1, 2, 3, 4, 5]
```

## Usando .sort() de orden natural (forma legado)

Orden natural es el orden alfabéticamente.

```
import java.util.ArrayList;

import java.util.Collections;


ArrayList<Integer> lista = new ArrayList<>();
lista.add(5);
lista.add(2);
lista.add(3);
lista.add(1);
lista.add(4);
				
//  clase anónima
Collections.sort(lista, new Comparator<Integer>() {
	public int compare(Integer o1, Integer o2) {
		if (o1 == o2) {
				return 0;
		} else if (o1 > o2) {
				return 1;
		} else {
				return -1;
		}
	}
});
		
System.out.println(lista);
//  [5, 2, 3, 1, 4]
//  [1, 2, 3, 4, 5]
```


# .sort() - expresiones lambda

[https://www.baeldung.com/java-8-sort-lambda](https://www.baeldung.com/java-8-sort-lambda)

Se puede usar expresiones lambda en el cuerpo de método `.compare(Object a, Object b)` de interfaz `Comparator<TipoObjeto>`.

Esto se realiza en el método `.sort()`.

```
songList.sort((one, two) -> one.getTitle().compareTo(two.getTitle());
```

Usando funciones lambda se ahorra la necesidad de implementar clases nuevas, ahorrando código.


## Expresiones lambda en Comparator

Se puede utilizar funciones lambda para implementar interfaz `Comparator`.

Se debe instanciar la clase y aplicar la expresión lambda.

```
Comparator<Cancion> comparator = (h1, h2) -> h1.getName().compareTo(h2.getName());

listCanciones.sort(comparator.reversed());
```

Recordar que `Comparator` tiene otros métodos como `reversed()` que invierte orden de lista ordenada.


## sort() - expresión lambda - Múltiples condiciones

Se puede construir expresiones más complejas aún, usando condicionales dentro de la expresión.

```
listaCanciones.sort((h1, h2) -> {
    if (h1.getName().equals(h2.getName())) {
        return Integer.compare(h1.getYearRelease(), h2.getYearRelease());
    } else {
        return h1.getName().compareTo(h2.getName());
    }
});
```


## .sort() - stream() - Expresiones lambda

Usando `.stream()` en colecciones.

Se crea una instancia de interfaz `Comparator`, se usa expresión lambda.

Luego se crea una lista nueva que almacenará la lista resultante del `.stream()`.

```
Comparator<Cancion> nameComparator = (c1, c2) -> c1.getName().compareTo(c2.getName());

List<Cancion> sortedCanciones = listaCanciones.stream().sorted(nameComparator).collect(Collectors.toList());
```

Para invertir el orden, se debe modificar el comparador `nameComparator` (instancia de `Comparator`) quedando así:

```
Comparator<Cancion> nameComparator = (c1, c2) -> c2.getName().compareTo(c1.getName());
```



# .filter() - java.util.Collection

[.filter()](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/stream/Stream.html#filter(java.util.function.Predicate))

[https://www.baeldung.com/java-stream-filter-lambda][https://www.baeldung.com/java-stream-filter-lambda]

[Stream](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/stream/Stream.html)


Método **[.filter()](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/stream/Stream.html#filter(java.util.function.Predicate))** es una operación intermedia de la interface **[Stream](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/stream/Stream.html)** que permite filtrar elementos de un stream (flujo) que coincidan con el *Predicate*.

`.filter()` permite multiples criterios de filtrado.


```
Customer john = new Customer("John P.", 15);
Customer sarah = new Customer("Sarah M.", 200);
Customer charles = new Customer("Charles B.", 150);
Customer mary = new Customer("Mary T.", 1);

List<Customer> customers = Arrays.asList(john, sarah, charles, mary);

List<Customer> charlesWithMoreThan100Points = customers
  .stream()
  .filter(c -> c.getPoints() > 100 && c.getName().startsWith("Charles"))
  .collect(Collectors.toList());

assertThat(charlesWithMoreThan100Points).hasSize(1);
assertThat(charlesWithMoreThan100Points).contains(charles);
```



# Iterator - java.util.Iterator

[https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)


**Iterator** permite iterar una coleccion sin importar cual esta fuera.

*Iterator* es un objeto que tiene al menos dos métodos:

* hashNext()
* next()

Para iterar se debe utilizar en un bucle y utilizar los métodos de *Iterator*.

Ejemplo en *List*, *ArrayList*, *LinkedList*, *Vector*.
```
List<String> nombres = new ArrayList<>();
nombres.add("Super Mario");
nombres.add("Yoshi"); 
nombres.add("Donkey Kong"); 

Iterator<String> it = nombres.iterator();

while(it.hasNext()) {
  System.out.println(it.next());
}
```


Ejemplo en *Queue*, *Set*, *Map*.
```
Set<String> nombres = new HashSet<>();
nombres.add("Super Mario");
nombres.add("Yoshi"); 
nombres.add("Donkey Kong"); 

Iterator<String> it = nombres.iterator();

while(it.hasNext()) {
  System.out.println(it.next());
}
```



